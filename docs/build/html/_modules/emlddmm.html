<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>emlddmm &mdash; GDM 0.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> GDM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Module code</a> &raquo;</li>
      <li>emlddmm</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for emlddmm</h1><div class="highlight"><pre>
<span></span><span class="c1">#from turtle import forward</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.nn.functional</span> <span class="kn">import</span> <span class="n">grid_sample</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">nibabel</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="c1">#from skimage import measure, filters</span>
<span class="c1">#from mayavi import mlab</span>
<span class="c1"># import nrrd</span>
<span class="c1"># from scipy.spatial.distance import directed_hausdorff, dice</span>
<span class="c1"># from medpy.metric import binary</span>
<span class="kn">import</span> <span class="nn">tifffile</span> <span class="k">as</span> <span class="nn">tf</span> <span class="c1"># for 16 bit tiff</span>

<span class="c1"># display</span>
<div class="viewcode-block" id="draw"><a class="viewcode-back" href="../emlddmm.html#emlddmm.draw">[docs]</a><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n_slices</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot; Draw 3D imaging data.</span>
<span class="sd">    </span>
<span class="sd">    Images are shown by sampling slices along 3 orthogonal axes.</span>
<span class="sd">    Color or grayscale data can be shown.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : array like (torch tensor or numpy array)</span>
<span class="sd">        A 3D image with C channels should be size (C x nslice x nrow x ncol)</span>
<span class="sd">        Note grayscale images should have C=1, but still be a 4D array.</span>
<span class="sd">    xJ : list</span>
<span class="sd">        A list of 3 numpy arrays.  xJ[i] contains the positions of voxels</span>
<span class="sd">        along axis i.  Note these are assumed to be uniformly spaced. The default</span>
<span class="sd">        is voxels of size 1.0.</span>
<span class="sd">    fig : matplotlib figure</span>
<span class="sd">        A figure in which to draw pictures. Contents of hte figure will be cleared.</span>
<span class="sd">        Default is None, which creates a new figure.</span>
<span class="sd">    n_slices : int</span>
<span class="sd">        An integer denoting how many slices to draw along each axis. Default 5.</span>
<span class="sd">    vmin</span>
<span class="sd">        A minimum value for windowing imaging data. Can also be a list of size C for</span>
<span class="sd">        windowing each channel separately. Defaults to None, which corresponds </span>
<span class="sd">        to tha 0.001 quantile on each channel.</span>
<span class="sd">    vmax</span>
<span class="sd">        A maximum value for windowing imaging data. Can also be a list of size C for</span>
<span class="sd">        windowing each channel separately. Defaults to None, which corresponds </span>
<span class="sd">        to tha 0.999 quantile on each channel.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Other keywords will be passed on to the matplotlib imshow function. For example</span>
<span class="sd">        include cmap=&#39;gray&#39; for a gray colormap</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig : matplotlib figure</span>
<span class="sd">        The matplotlib figure variable with data.</span>
<span class="sd">    axs : array of matplotlib axes</span>
<span class="sd">        An array of matplotlib subplot axes containing each image.</span>


<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Here is an example::</span>

<span class="sd">       &gt;&gt;&gt; example test</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xJ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nJ</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nJ</span><span class="p">]</span> 
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>    
    <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="mf">0.001</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="mf">0.999</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>    
    <span class="c1"># I will normalize data with vmin, and display in 0,1</span>
    <span class="k">if</span> <span class="n">vmin</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">vmax</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># for rgb I&#39;ll scale it, otherwise I won&#39;t, so I can use colorbars</span>
        <span class="n">J</span> <span class="o">-=</span> <span class="n">vmin</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">J</span> <span class="o">/=</span> <span class="p">(</span><span class="n">vmax</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>
        <span class="n">J</span><span class="p">[</span><span class="n">J</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J</span><span class="p">[</span><span class="n">J</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># I will only sohw the first 3 channels</span>
    <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    
    
    <span class="n">axs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">axsi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ax0</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>        
    <span class="c1"># for origin upper (default), extent is x (small to big), then y reversed (big to small)</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_slices</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n_slices</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">toshow</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">toshow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="n">toshow</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axsi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axsi</span><span class="p">)</span>
    <span class="n">axsi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ax1</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>    
    <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_slices</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n_slices</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">n_slices</span><span class="p">)</span>      
        <span class="n">toshow</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,:,</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">toshow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="n">toshow</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axsi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axsi</span><span class="p">)</span>
    <span class="n">axsi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ax2</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>        
    <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_slices</span><span class="p">):</span>        
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n_slices</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">n_slices</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">toshow</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,:,:,</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">toshow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="n">toshow</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axsi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axsi</span><span class="p">)</span>
    
    <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">hspace</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span><span class="n">axs</span></div>
    
    
<div class="viewcode-block" id="load_slices"><a class="viewcode-back" href="../emlddmm.html#emlddmm.load_slices">[docs]</a><span class="k">def</span> <span class="nf">load_slices</span><span class="p">(</span><span class="n">target_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load a slice dataset.</span>
<span class="sd">    </span>
<span class="sd">    Load a slice dataset for histology registration. Slice datasets include pairs</span>
<span class="sd">    of images and json sidecar files, as well as one tsv file explaining the dataset.</span>
<span class="sd">    Note this code creates a 3D array by padding.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_name : string</span>
<span class="sd">        Name of a directory containing slice dataset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xJ : list of numpy arrays</span>
<span class="sd">        Location of v</span>
<span class="sd">    J : numpy array</span>
<span class="sd">        Numpy array of size C x nslices x nrows x ncols where C is the number of channels</span>
<span class="sd">        e.g. C=3 for RGB.</span>
<span class="sd">    W0 : numpy array</span>
<span class="sd">        A nslices x nrows x ncols numpy array containing weights.  Weights are 0 where there </span>
<span class="sd">        was padding</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Document describing dataset format here: TODO XXXXX</span>
<span class="sd">    documented XXXX</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading target images&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>
    <span class="c1"># current limitation</span>
    <span class="c1"># requires the word &#39;present&#39;</span>
    <span class="c1"># requires the first image to be present</span>
    <span class="c1"># expects data type to be in 0,1</span>
    <span class="c1"># assumes space directions are diagonal</span>
    <span class="c1"># todo: origin</span>
    <span class="c1"># we will need more control over the size, and we will need to maintain the origin of each slice</span>
    <span class="c1"># right now we have a heuristic for taking 99th percentile and expanding by 1%</span>
    
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># load the one tsv file</span>
    <span class="n">tsv_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="s1">&#39;samples.tsv&#39;</span> <span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tsv_name</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">count</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">line</span> <span class="k">else</span> <span class="s1">&#39;    &#39;</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">headings</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>                
                <span class="k">continue</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">line</span><span class="p">))</span>
    <span class="n">data_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data_</span>
    
    <span class="c1"># now we will loop through the files and get the sizes </span>
    <span class="n">nJ_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">J_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">namekey</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">searchstring</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="o">+</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">namekey</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;*.json&#39;</span><span class="p">)</span>
        <span class="n">jsonfile</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">searchstring</span><span class="p">)</span>
        <span class="n">present</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;present&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">present</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;First image is not present&#39;</span><span class="p">)</span>
            <span class="n">J_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]]]))</span>
            <span class="k">continue</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">jsonfile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">jsondata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1">#nJ_[i] = np.array(jsondata[&#39;Sizes&#39;])</span>


        <span class="c1"># this should contain an image and a json    </span>
        <span class="k">if</span> <span class="s1">&#39;DataFile&#39;</span> <span class="ow">in</span> <span class="n">jsondata</span><span class="p">:</span>
            <span class="n">image_name</span> <span class="o">=</span> <span class="n">jsondata</span><span class="p">[</span><span class="s1">&#39;DataFile&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;DataFIle&#39;</span> <span class="ow">in</span> <span class="n">jsondata</span><span class="p">:</span>
            <span class="n">image_name</span> <span class="o">=</span> <span class="n">jsondata</span><span class="p">[</span><span class="s1">&#39;DataFIle&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span><span class="n">image_name</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">J__</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="mf">255.0</span>

        <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># no alpha</span>

        <span class="n">nJ_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J__</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">J_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J__</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">%</span><span class="mi">20</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">J__</span><span class="p">)</span>


            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slice </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">image_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="c1"># the domain</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jsondata</span><span class="p">[</span><span class="s1">&#39;SpaceDirections&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># note the order needs to be reversed</span>

        <span class="c1"># if this is the first file we want to set up a 3D volume</span>
        
    <span class="n">nJm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nJ_</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">nJm</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">nJ_</span><span class="p">,</span><span class="mf">0.95</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mf">1.01</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> 
    <span class="c1"># this will look for outliers when there are a small number, </span>
    <span class="c1"># really there just shouldn&#39;t be outliers</span>
    <span class="n">nJsave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">nJ_</span><span class="p">)</span> 
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;padding and assembling into 3D volume&#39;</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">nJm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nJm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">W0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">nJm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nJm</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">J_</span><span class="p">)):</span>
        <span class="n">J__</span> <span class="o">=</span> <span class="n">J_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">topad</span> <span class="o">=</span> <span class="n">nJm</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nJ_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># just pad on the left and I&#39;ll fill it in</span>
        <span class="n">topad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="n">topad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="n">topad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
        <span class="c1"># if there are any negative values I need to crop, I&#39;ll just crop on the right</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">topad</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">topad</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="p">[:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">topad</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">topad</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="p">[:,:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="n">topad</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Jp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">J__</span><span class="p">,</span><span class="n">topad</span><span class="p">,</span><span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">W0_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Jp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">Jp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Jp</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">W0</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="n">W0_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">W0_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">W0_</span>
        <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="n">W0_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">W0_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">Jp</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">J</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>    
    <span class="n">nJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dJ</span><span class="p">)]</span>
    <span class="n">W0</span> <span class="o">=</span> <span class="n">W0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">J</span><span class="o">==</span><span class="mf">0.0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">W0</span> <span class="o">=</span> <span class="n">W0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">J</span><span class="o">==</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="c1"># free up memory, not sure if this is necessary inside a function</span>
    <span class="k">del</span> <span class="n">J_</span>
    <span class="k">return</span> <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span></div>
    

            
<span class="c1"># resampling</span>
<div class="viewcode-block" id="sinc_resample_numpy"><a class="viewcode-back" href="../emlddmm.html#emlddmm.sinc_resample_numpy">[docs]</a><span class="k">def</span> <span class="nf">sinc_resample_numpy</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Perform sinc resampling of an image in numpy.</span>
<span class="sd">    </span>
<span class="sd">    This function does sinc resampling using numpy rfft</span>
<span class="sd">    torch does not let us control behavior of fft well enough</span>
<span class="sd">    This is intended to be used to resample velocity fields if necessary</span>
<span class="sd">    Only intending it to be used for upsampling.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : numpy array</span>
<span class="sd">        An image to be resampled. Can be an arbitrary number of dimensions.</span>
<span class="sd">    n : list of ints</span>
<span class="sd">        Desired dimension of output data.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Id : numpy array</span>
<span class="sd">        A resampled image of size n.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>        
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># output with correct normalization</span>
    <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Id</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">Id</span></div>
    

<div class="viewcode-block" id="downsample_ax"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downsample_ax">[docs]</a><span class="k">def</span> <span class="nf">downsample_ax</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Downsample imaging data along one of the first 5 axes.</span>
<span class="sd">    </span>
<span class="sd">    Imaging data is downsampled by averaging nearest pixels.</span>
<span class="sd">    Note that data will be lost from the end of images instead of padding.</span>
<span class="sd">    This function is generally called repeatedly on each axis.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : array like (numpy or torch)</span>
<span class="sd">        Image to be downsampled on one axis.</span>
<span class="sd">    down : int</span>
<span class="sd">        Downsampling factor.  2 means average pairs of nearest pixels </span>
<span class="sd">        into one new downsampled pixel</span>
<span class="sd">    ax : int</span>
<span class="sd">        Which axis to downsample along.</span>
<span class="sd">    W : np array</span>
<span class="sd">        A mask the same size as I, but without a &quot;channel&quot; dimension</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Id : array like</span>
<span class="sd">        The downsampled image.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>        
    <span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">//</span><span class="n">down</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">device</span><span class="o">=</span><span class="n">W</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">W</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="n">W</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>            
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="c1"># ... should be enough but there really has to be a better way to do this        </span>
            <span class="c1"># note I could use &quot;take&quot;</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span><span class="o">/</span><span class="n">down</span>
        <span class="k">return</span> <span class="n">Id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if W is not none</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;W not supported with ax=0&#39;</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span> <span class="o">/</span> <span class="p">(</span><span class="n">Wd</span> <span class="o">+</span> <span class="n">Wd</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>
        
        
        <span class="n">Wd</span> <span class="o">=</span> <span class="n">Wd</span> <span class="o">/</span> <span class="n">down</span>
        <span class="k">return</span> <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span></div>
        
<div class="viewcode-block" id="downsample"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downsample">[docs]</a><span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Downsample an image by an integer factor along each axis. Note extra data at </span>
<span class="sd">    the end will be truncated if necessary.</span>
<span class="sd">    </span>
<span class="sd">    If the first axis is for image channels, downsampling factor should be 1 on this.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : array (numpy or torch)</span>
<span class="sd">        Imaging data to downsample</span>
<span class="sd">    down : list of int</span>
<span class="sd">        List of downsampling factors for each axis.</span>
<span class="sd">    W : array (numpy or torch)</span>
<span class="sd">        A weight of the same size as I but without the &quot;channel&quot; dimension</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Id : array (numpy or torch as input)</span>
<span class="sd">        Downsampled imaging data.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">down</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">down</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">down</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">down</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Id</span> <span class="o">=</span> <span class="n">downsample_ax</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span> <span class="o">=</span> <span class="n">downsample_ax</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">Wd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span></div>


<div class="viewcode-block" id="downsample_image_domain"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downsample_image_domain">[docs]</a><span class="k">def</span> <span class="nf">downsample_image_domain</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Downsample an image as well as pixel locations</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xI : list of numpy arrays</span>
<span class="sd">        xI[i] is a numpy array storing the locations of each voxel</span>
<span class="sd">        along the i-th axis.</span>
<span class="sd">    I : array like</span>
<span class="sd">        Image to be downsampled</span>
<span class="sd">    down : list of ints</span>
<span class="sd">        Factor by which to downsample along each dimension</span>
<span class="sd">    W : array like</span>
<span class="sd">        Weights the same size as I, but without a &quot;channel&quot; dimension</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xId : list of numpy arrays</span>
<span class="sd">        New voxel locations in the same format as xI</span>
<span class="sd">    Id : numpy array</span>
<span class="sd">        Downsampled image.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xI</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Length of down and xI must be equal&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">)</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">)</span>
    <span class="n">xId</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="n">xId</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsample_ax</span><span class="p">(</span><span class="n">xI</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">d</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xId</span><span class="p">,</span><span class="n">Id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xId</span><span class="p">,</span><span class="n">Id</span><span class="p">,</span><span class="n">Wd</span></div>

<span class="c1"># build an interp function from grid sample</span>
<div class="viewcode-block" id="interp"><a class="viewcode-back" href="../emlddmm.html#emlddmm.interp">[docs]</a><span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phii</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Interpolate a 3D image with specified regular voxel locations at specified sample points.</span>
<span class="sd">    </span>
<span class="sd">    Interpolate the 3D image I, with regular grid positions stored in x (1d arrays),</span>
<span class="sd">    at the positions stored in phii (3D arrays with first channel storing component)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        x[i] is a numpy array storing the pixel locations of imaging data along the i-th axis.</span>
<span class="sd">        Note that this MUST be regularly spaced, only the first and last values are queried.</span>
<span class="sd">    I : array</span>
<span class="sd">        Numpy array or torch tensor storing 3D imaging data.  I is a 4D array with </span>
<span class="sd">        channels along the first axis and spatial dimensions along the last 3 </span>
<span class="sd">    phii : array</span>
<span class="sd">        Numpy array or torch tensor storing positions of the sample points. phii is a 4D array</span>
<span class="sd">        with components along the first axis (e.g. x0,x1,x1) and spatial dimensions </span>
<span class="sd">        along the last 3.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        keword arguments to be passed to the grid sample function. For example</span>
<span class="sd">        to specify interpolation type like nearest.  See pytorch grid_sample documentation.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : torch tensor</span>
<span class="sd">        4D array storing a 3D image with channels stored along the first axis. </span>
<span class="sd">        This is the input image resampled at the points stored in phii.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># first we have to normalize phii to the range -1,1    </span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">phii</span><span class="p">)</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">phii</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">phii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># note the above maps to 0,1</span>
    <span class="n">phii</span> <span class="o">*=</span> <span class="mf">2.0</span>
    <span class="c1"># to 0 2</span>
    <span class="n">phii</span> <span class="o">-=</span> <span class="mf">1.0</span>
    <span class="c1"># done</span>
        
    <span class="c1"># NOTE I should check that I can reproduce identity</span>
    <span class="c1"># note that phii must now store x,y,z along last axis</span>
    <span class="c1"># is this the right order?</span>
    <span class="c1"># I need to put batch (none) along first axis</span>
    <span class="c1"># what order do the other 3 need to be in?    </span>
    <span class="c1"># feb 2022</span>
    <span class="k">if</span> <span class="s1">&#39;padding_mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;padding_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;border&#39;</span> <span class="c1"># note that default is zero</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">grid_sample</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span><span class="n">phii</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="kc">None</span><span class="p">],</span><span class="n">align_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># note align corners true means square voxels with points at their centers</span>
    <span class="c1"># post processing, get rid of batch dimension</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span></div>
    
<span class="c1"># now we need to create a flow</span>
<span class="c1"># timesteps will be along the first axis</span>
<div class="viewcode-block" id="v_to_phii"><a class="viewcode-back" href="../emlddmm.html#emlddmm.v_to_phii">[docs]</a><span class="k">def</span> <span class="nf">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Use Euler&#39;s method to construct a position field from a velocity field</span>
<span class="sd">    by integrating over time.</span>
<span class="sd">    </span>
<span class="sd">    This method uses interpolation and subtracts and adds identity for better</span>
<span class="sd">    behavior outside boundaries. This method is sometimes refered to as the</span>
<span class="sd">    method of characteristics.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xv : list of 1D tensors</span>
<span class="sd">        xv[i] is a tensor storing the location of the sample points along</span>
<span class="sd">        the i-th dimension of v</span>
<span class="sd">    v : 5D tensor</span>
<span class="sd">        5D tensor where first axis corresponds to time, second corresponds to </span>
<span class="sd">        component, and 3rd to 5th correspond to spatial dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    phii : 4D tensor</span>
<span class="sd">        Inverse transformation is output with component on the first dimension</span>
<span class="sd">        and space on the last 3. Note that the whole timeseries is not output.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">))</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XV</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">XV</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span><span class="o">+</span><span class="n">Xs</span>
    <span class="k">return</span> <span class="n">phii</span></div>
        
    
<div class="viewcode-block" id="reshape_for_local"><a class="viewcode-back" href="../emlddmm.html#emlddmm.reshape_for_local">[docs]</a><span class="k">def</span> <span class="nf">reshape_for_local</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Reshapes an image into blocks for simple local contrast estimation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : tensor</span>
<span class="sd">        3D image data where first index stores the channel information (i.e. 4D array)</span>
<span class="sd">    local_contrast : tensor</span>
<span class="sd">        1D tensor storing the block size on each dimension</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Jv : tensor</span>
<span class="sd">        Reshaped imaging data to be used for contrast estimation</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># get shapes and pad</span>
    <span class="n">Jshape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">device</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">topad</span> <span class="o">=</span> <span class="n">Jshape</span><span class="o">%</span><span class="n">local_contrast</span>
    <span class="n">topad</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_contrast</span><span class="o">-</span><span class="n">topad</span><span class="p">)</span><span class="o">%</span><span class="n">local_contrast</span>    
    <span class="n">Jpad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">J</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="n">topad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="n">topad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="n">topad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>              
    
    <span class="c1"># now reshape it</span>
    <span class="n">Jpad_</span> <span class="o">=</span> <span class="n">Jpad</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">(</span><span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">//</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">//</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
    <span class="n">Jpad__</span> <span class="o">=</span> <span class="n">Jpad_</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Jpadv</span> <span class="o">=</span> <span class="n">Jpad__</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                           <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Jpadv</span></div>
                           
<div class="viewcode-block" id="reshape_from_local"><a class="viewcode-back" href="../emlddmm.html#emlddmm.reshape_from_local">[docs]</a><span class="k">def</span> <span class="nf">reshape_from_local</span><span class="p">(</span><span class="n">Jv</span><span class="p">,</span><span class="n">local_contrast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    After changing contrast, transform back</span>
<span class="sd">    &#39;&#39;&#39;</span></div>
    
<div class="viewcode-block" id="emlddmm"><a class="viewcode-back" href="../emlddmm.html#emlddmm.emlddmm">[docs]</a><span class="k">def</span> <span class="nf">emlddmm</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Run the EMLDDMM algorithm for deformable registration between two</span>
<span class="sd">    different imaging modalities with possible missing data in one of them</span>
<span class="sd">    </span>
<span class="sd">    Details of this algorithm can be found in</span>
<span class="sd">    [1] Tward, Daniel, et al. &quot;Diffeomorphic registration with intensity </span>
<span class="sd">    transformation and missing data: Application to 3D digital pathology </span>
<span class="sd">    of Alzheimer&#39;s disease.&quot; Frontiers in neuroscience 14 (2020): 52.</span>
<span class="sd">    [2] Tward, Daniel, et al. &quot;3d mapping of serial histology sections </span>
<span class="sd">    with anomalies using a novel robust deformable registration algorithm.&quot; </span>
<span class="sd">    Multimodal Brain Image Analysis and Mathematical Foundations of </span>
<span class="sd">    Computational Anatomy. Springer, Cham, 2019. 162-173.</span>
<span class="sd">    [3] Tward, Daniel, et al. &quot;Solving the where problem in neuroanatomy: </span>
<span class="sd">    a generative framework with learned mappings to register multimodal, </span>
<span class="sd">    incomplete data into a reference brain.&quot; bioRxiv (2020).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Note all parameters are keyword arguments, but the first four are required.    </span>
<span class="sd">    xI : list of arrays</span>
<span class="sd">        xI[i] stores the location of voxels on the i-th axis of the atlas image I (REQUIRED)</span>
<span class="sd">    I : 4D array (numpy or torch)</span>
<span class="sd">        4D array storing atlas imaging data.  Channels (e.g. RGB are stored on the </span>
<span class="sd">        first axis, and the last three are spatial dimensions. (REQUIRED)</span>
<span class="sd">    xJ : list of arrays</span>
<span class="sd">        xJ[i] stores the location of voxels on the i-th axis of the target image J (REQUIRED)</span>
<span class="sd">    J : 4D array (numpy or torch)</span>
<span class="sd">        4D array storing target imaging data.  Channels (e.g. RGB are stored on the </span>
<span class="sd">        first axis, and the last three are spatial dimensions. (REQUIRED)</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of timesteps for integrating a velocity field to yeild a position field (default 5).</span>
<span class="sd">    eA : float</span>
<span class="sd">        Gradient descent step size for affine component (default 1e-5).  It is strongly suggested</span>
<span class="sd">        that you test this value and not rely on defaults. Note linear and translation components</span>
<span class="sd">        are combined following [ref] so only one stepsize is required.</span>
<span class="sd">    ev : float</span>
<span class="sd">        Gradient descent step size for affine component (default 1e-5).  It is strongly suggested</span>
<span class="sd">        that you test this value and not rely on defaults.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        Returns a dictionary of outputs storing computing transforms. if full_outputs==True, </span>
<span class="sd">        then more data is output including figures.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># required arguments are</span>
    <span class="c1"># I - atlas image, size C x slice x row x column</span>
    <span class="c1"># xI - list of pixels locations in I, corresponding to each axis other than channels</span>
    <span class="c1"># J - target image, size C x slice x row x column</span>
    <span class="c1"># xJ - list of pixel locations in J</span>
    <span class="c1"># other parameters are specified in a dictionary with defaults listed below</span>
    <span class="c1"># if you provide an input for PARAMETER it will be used as an initial guess, </span>
    <span class="c1"># unless you specify update_PARAMETER=False, in which case it will be fixed</span>
    <span class="c1"># if you specify update_sigmaM=False it will use sum of square error, </span>
    <span class="c1"># otherwise it will use log determinant of diagonal covariance matrix</span>
    
    <span class="c1"># I should move them to torch and put them on the right device</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xI&#39;</span><span class="p">]</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xJ&#39;</span><span class="p">]</span>
    
    <span class="c1">##########################################################################################################</span>
    <span class="c1"># everything else is optinal, defaults are below</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nt&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;eA&#39;</span><span class="p">:</span><span class="mf">1e5</span><span class="p">,</span>
                <span class="s1">&#39;ev&#39;</span><span class="p">:</span><span class="mf">2e3</span><span class="p">,</span>
                <span class="s1">&#39;order&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># order of polynomial</span>
                <span class="s1">&#39;n_draw&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;sigmaR&#39;</span><span class="p">:</span><span class="mf">1e6</span><span class="p">,</span>
                <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span><span class="mi">2000</span><span class="p">,</span>
                <span class="s1">&#39;n_e_step&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;v_start&#39;</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span>
                <span class="s1">&#39;n_reduce_step&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;v_expand_factor&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span>
                <span class="s1">&#39;v_res_factor&#39;</span><span class="p">:</span><span class="mf">2.0</span><span class="p">,</span>
                <span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># note default below dv[0]*2.0</span>
                <span class="s1">&#39;p&#39;</span><span class="p">:</span><span class="mf">2.0</span><span class="p">,</span>    
                <span class="s1">&#39;aprefactor&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span> <span class="c1"># in terms of voxels in the downsampled atlas</span>
                <span class="s1">&#39;device&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># cuda:0 if available otherwise cpu</span>
                <span class="s1">&#39;dtype&#39;</span><span class="p">:</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span>
                <span class="s1">&#39;downI&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;downJ&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>      
                <span class="s1">&#39;W0&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;priors&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_priors&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;full_outputs&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;muB&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_muB&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;muA&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_muA&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;sigmaA&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_sigmaA&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;sigmaB&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_sigmaB&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;sigmaM&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_sigmaM&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;Amode&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># 0 for standard, 1 for rigid, 2 for rigid+scale</span>
                <span class="s1">&#39;v&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;A2d&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>     
                <span class="s1">&#39;eA2d&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">,</span> <span class="c1"># removed eL and eT using metric, need to double check 2d case works well</span>
                <span class="s1">&#39;slice_matching&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># if true include rigid motions and contrast on each slice</span>
                <span class="s1">&#39;slice_matching_start&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;slice_matching_isotropic&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># if true 3D affine is isotropic scale</span>
                <span class="s1">&#39;local_contrast&#39;</span><span class="p">:[],</span> <span class="c1"># simple local contrast estimation mode, should be a list of ints</span>
                <span class="s1">&#39;reduce_factor&#39;</span><span class="p">:</span><span class="mf">0.9</span><span class="p">,</span>
               <span class="p">}</span>
    <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">defaults</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cuda:0&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span>
    
    <span class="c1"># move the above to the right device</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    
    
    <span class="c1">##########################################################################################################</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nt&#39;</span><span class="p">]</span>
    <span class="n">eA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;eA&#39;</span><span class="p">]</span>
    <span class="n">ev</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ev&#39;</span><span class="p">]</span>
    <span class="n">eA2d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;eA2d&#39;</span><span class="p">]</span>
    <span class="n">reduce_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;reduce_factor&#39;</span><span class="p">]</span>
    
    <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> 
    
    <span class="n">sigmaR</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaR&#39;</span><span class="p">]</span>
    <span class="n">n_iter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_iter&#39;</span><span class="p">]</span>
    <span class="n">v_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v_start&#39;</span><span class="p">]</span>
    <span class="n">n_draw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_draw&#39;</span><span class="p">]</span>
    <span class="n">n_e_step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_e_step&#39;</span><span class="p">]</span>
    <span class="n">n_reduce_step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_reduce_step&#39;</span><span class="p">]</span>
    
    <span class="n">v_expand_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v_expand_factor&#39;</span><span class="p">]</span>
    <span class="n">v_res_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v_res_factor&#39;</span><span class="p">]</span>
    
    <span class="n">a</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
    <span class="n">aprefactor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;aprefactor&#39;</span><span class="p">]</span>
        
    
    <span class="n">downI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span>
    <span class="n">downJ</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">]</span>
    <span class="n">W0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;W0&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">W0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># this has only one channel and should not have extra dimension in front</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">W0</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W0</span><span class="p">)</span> 
    <span class="n">priors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;priors&#39;</span><span class="p">]</span>
    <span class="n">update_priors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_priors&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">priors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update_priors</span><span class="p">:</span>        
        <span class="n">priors</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]</span>
    <span class="n">full_outputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;full_outputs&#39;</span><span class="p">]</span>
    <span class="n">muA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;muA&#39;</span><span class="p">]</span>
    <span class="n">update_muA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_muA&#39;</span><span class="p">]</span>
    <span class="n">muB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;muB&#39;</span><span class="p">]</span>
    <span class="n">update_muB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_muB&#39;</span><span class="p">]</span>
    <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaA&#39;</span><span class="p">]</span>
    <span class="n">update_sigmaA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_sigmaA&#39;</span><span class="p">]</span>
    <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaB&#39;</span><span class="p">]</span>
    <span class="n">update_sigmaB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_sigmaB&#39;</span><span class="p">]</span>
    <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaM&#39;</span><span class="p">]</span>
    <span class="n">update_sigmaM</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_sigmaM&#39;</span><span class="p">]</span>
    
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">Amode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;Amode&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
    <span class="n">slice_matching</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">slice_matching</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slice_matching</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
    <span class="n">slice_matching_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching_start&#39;</span><span class="p">]</span>
    <span class="n">slice_matching_isotropic</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching_isotropic&#39;</span><span class="p">]</span>
    
    <span class="c1"># local contrast, a list of ints, if empty don&#39;t do it</span>
    <span class="n">local_contrast</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;local_contrast&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">local_contrast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">local_contrast</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">local_contrast</span><span class="p">:</span>
        <span class="n">local_contrast</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    
    
    <span class="c1">##########################################################################################################    </span>
    <span class="c1"># domain</span>
    <span class="n">dI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">dJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>    
    <span class="n">nI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">nJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    <span class="c1"># set up a domain for xv    </span>
    <span class="c1"># I&#39;ll put it a bit bigger than xi</span>
    <span class="n">dv</span> <span class="o">=</span> <span class="n">dI</span><span class="o">*</span><span class="n">v_res_factor</span> <span class="c1"># we want this to be independent of the I downsampling, </span>
    <span class="c1"># feb 4, 2022, I want it to be isotropic though</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dv </span><span class="si">{</span><span class="n">dv</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">2.0</span> <span class="c1"># so this is also independent of the I downsampling amount</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a scale is </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">x0v</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">v_expand_factor</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">x1v</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">v_expand_factor</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x0v</span><span class="p">,</span><span class="n">x1v</span><span class="p">,</span><span class="n">dv</span><span class="p">)]</span>
    <span class="n">nv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">))</span>
    <span class="c1">#print(f&#39;velocity size is {nv}&#39;)</span>
    
    
    <span class="c1"># downample    </span>
    <span class="n">xI</span><span class="p">,</span><span class="n">I</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">downI</span><span class="p">)</span>
    <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">downJ</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">W0</span><span class="p">)</span>
    <span class="n">dI</span> <span class="o">*=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">downI</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="n">dJ</span> <span class="o">*=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">downJ</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># I think the above two lines are wrong, let&#39;s just repeat</span>
    <span class="n">dI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">dJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>    
    <span class="n">nI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">nJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    <span class="n">vminI</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.001</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
    <span class="n">vmaxI</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.999</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
    <span class="n">vminJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.001</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">]</span>
    <span class="n">vmaxJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.999</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">]</span>
    
        
    <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xI</span><span class="p">))</span>
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xJ</span><span class="p">))</span>
    
    
    <span class="c1"># build an affine metric for 3D affine</span>
    <span class="c1"># this one is based on pullback metric from action on voxel locations (not image)</span>
    <span class="c1"># build a basis in lexicographic order and push forward using the voxel locations</span>
    <span class="n">XI_</span> <span class="o">=</span> <span class="n">XI</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>    
    <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># it would be nice to define scaling so that the norm of a perturbation had units of microns</span>
    <span class="c1"># e.g. root mean square displacement</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
        <span class="n">EiX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
            <span class="n">EjX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># matrix multiplication            </span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EiX</span><span class="o">*</span><span class="n">EjX</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dI</span><span class="p">)</span> <span class="c1"># because gradient has a factor of N in it, I think its a good idea to do sum</span>
    <span class="c1"># note, on july 21 I add factor of voxel size, so it can cancel with factor in cost function</span>

    <span class="c1"># feb 2, 2022, use double precision.  TODO: implement this as a solve when it is applied instead of inverse</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">double</span><span class="p">())</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    

    <span class="c1"># TODO affine metric for 2D affine</span>
    <span class="c1"># I&#39;ll use a quick hack for now</span>
    <span class="c1"># this is again based on pullback metric for voxel locations</span>
    <span class="c1"># need to verify that this is correct given possibly moving coordinate</span>
    <span class="c1"># maybe better </span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">g2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
        <span class="n">EiX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,:])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
            <span class="n">EjX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,:])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">g2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EiX</span><span class="o">*</span><span class="n">EjX</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dI</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># feb 2, 2022, use double precision.  TODO: implement this as a solve when it is applied instead of inverse</span>
    <span class="n">g2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">g2d</span><span class="o">.</span><span class="n">double</span><span class="p">())</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            
    <span class="c1"># build energy operator for velocity</span>
    <span class="n">fv</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="o">/</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span><span class="n">dv</span><span class="p">)]</span>
    <span class="n">FV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fv</span><span class="p">))</span>

    <span class="n">LL</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> 
              <span class="p">(</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
            <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
            <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>   <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">LL</span>

    <span class="n">LLpre</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">aprefactor</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dI</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> 
             <span class="p">(</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
             <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
             <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>   <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Kpre</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">LLpre</span>
    <span class="n">KK</span> <span class="o">=</span> <span class="n">K</span><span class="o">*</span><span class="n">Kpre</span>

    
    
    
    <span class="c1"># now initialize variables and optimizers    </span>
    <span class="n">vsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vsize</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># check the size</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">==</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">vsize</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)):</span>
            <span class="c1"># note as_tensor will not do a copy if it is the same dtype and device</span>
            <span class="c1"># torch.tensor will always copy</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> 
            <span class="n">v</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Initial velocity must have 3 components&#39;</span><span class="p">)</span>
            <span class="c1"># resample it</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">sinc_resample_numpy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">vsize</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">v</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
            
            
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use tensor, not as_tensor, to make a copy</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">A</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">A2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">A2d</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use tensor not as tensor to make a copy</span>
            <span class="n">A2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A2d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">A2d</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># if slice matching is on we want to add xy translation in A to A2d</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A2di</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@vec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">WM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span>
    <span class="n">WA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>
    <span class="n">WB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>

    <span class="k">if</span> <span class="n">muA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>         
        <span class="c1">#muA = torch.tensor([torch.max(J_[W0&gt;0]) for J_ in J],dtype=dtype,device=device)      </span>
        <span class="n">muA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span> <span class="p">(</span><span class="n">J_</span><span class="p">[</span><span class="n">W0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="mf">0.999</span> <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if we input some value, we&#39;ll just use that</span>
        <span class="n">muA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">muA</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>    
    <span class="k">if</span> <span class="n">muB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#muB = torch.tensor([torch.min(J_[W0&gt;0]) for J_ in J],dtype=dtype,device=device)  </span>
        <span class="n">muB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span> <span class="p">(</span><span class="n">J_</span><span class="p">[</span><span class="n">W0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="mf">0.001</span> <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if we input a value we&#39;ll just use that</span>
        <span class="n">muB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">muB</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>        
    <span class="c1"># TODO update to covariance, for now just diagonal</span>
    <span class="n">DJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dJ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmaM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mf">1.0</span><span class="c1">#*DJ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">sigmaM</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmaA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mf">5.0</span><span class="c1">#*DJ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">sigmaA</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmaB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mf">2.0</span><span class="c1">#*DJ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">sigmaB</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_draw</span><span class="p">:</span> <span class="c1"># if n_draw is not 0, we create figures</span>
        <span class="n">figE</span><span class="p">,</span><span class="n">axE</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">figA</span><span class="p">,</span><span class="n">axA</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">axA</span> <span class="o">=</span> <span class="n">axA</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="n">figA2d</span><span class="p">,</span><span class="n">axA2d</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">axA2d</span> <span class="o">=</span> <span class="n">axA2d</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">figI</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figfI</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figErr</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figJ</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figV</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figW</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>


    <span class="n">Esave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Lsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Tsave</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">T2dsave</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">L2dsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">maxvsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sigmaMsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sigmaAsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sigmaBsave</span> <span class="o">=</span> <span class="p">[]</span>

    
    <span class="c1">################################################################################</span>
    <span class="c1"># end of setup, start optimization loop</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
        <span class="c1"># get the transforms        </span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="c1"># on the second iteration I was getting an error here </span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># 2D transforms</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>            
            <span class="n">XJ_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJ</span><span class="p">)</span>
            <span class="c1"># leave z component the same (x0) and transform others                   </span>
            <span class="n">XJ_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XJ_</span> <span class="o">=</span> <span class="n">XJ</span>

        <span class="c1"># sample points for affine</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ_</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># for diffeomorphism</span>
        <span class="n">phiiAi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs</span>
        
        <span class="c1"># transform image</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phiiAi</span><span class="p">)</span>        

        <span class="c1"># transform contrast</span>
        <span class="c1"># I&#39;d like to support two cases, order 1 and arbitrary dim</span>
        <span class="c1"># or order &gt; 1 and 1 dim</span>
        <span class="c1"># first step is to set up the basis functions</span>
        <span class="n">Nvoxels</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># why did I write 0, well its equal to 1 here        </span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span> <span class="c1"># an empty list means global contrast</span>
            <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nvoxels</span><span class="p">,</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                    <span class="n">B_</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this assumes atlas is only dim 1, okay for now</span>
            <span class="k">elif</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># in this case, I still need a column of ones</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nvoxels</span><span class="p">,</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="n">B_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Require either order = 1 or order&gt;1 and 1D atlas&#39;</span><span class="p">)</span>
            <span class="c1"># note B was size N voxels by N channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># simple approach to local contrast</span>
            <span class="c1"># we will pad and refactor</span>
            <span class="c1"># pad AphiI</span>
            <span class="c1"># permute</span>
            <span class="c1"># reshape</span>
            <span class="c1"># find out how much to pad</span>
            <span class="c1"># this weight variable will have zeros at the end</span>
            <span class="n">Wlocal</span> <span class="o">=</span> <span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span>           
            
            <span class="c1"># test</span>
            <span class="n">Jpadv</span> <span class="o">=</span> <span class="n">reshape_for_local</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">)</span>
            <span class="n">Wlocalpadv</span> <span class="o">=</span> <span class="n">reshape_for_local</span><span class="p">(</span><span class="n">Wlocal</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">)</span>
            <span class="n">AphiIpadv</span> <span class="o">=</span> <span class="n">reshape_for_local</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">)</span>
            
            <span class="c1"># now basis function</span>
            <span class="k">if</span> <span class="n">order</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>                
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;local not implemented yet except for linear&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">AphiIpadv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="n">AphiIpadv</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Require either order = 1 or order&gt;1 and 1D atlas&#39;</span><span class="p">)</span>
            
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
                <span class="c1"># global contrast mapping</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>                
                    <span class="c1"># multiply by weight</span>
                    <span class="n">B__</span> <span class="o">=</span> <span class="n">B_</span><span class="o">*</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                    <span class="c1"># feb 2, 2022 converted from inv to solve and used double</span>
                    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="n">B__</span><span class="o">.</span><span class="n">T</span><span class="nd">@B_</span><span class="p">)</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="p">(</span><span class="n">B__</span><span class="o">.</span><span class="n">T</span><span class="o">@</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">double</span><span class="p">()</span> <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">fAphiI</span> <span class="o">=</span> <span class="p">((</span><span class="n">B_</span><span class="nd">@coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># there are unnecessary transposes here, probably slowing down, to fix later</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># local contrast estimation using refactoring</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">BB</span> <span class="o">=</span> <span class="n">B_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="n">B_</span><span class="o">*</span><span class="n">Wlocalpadv</span><span class="p">)</span>
                    <span class="n">BJ</span> <span class="o">=</span> <span class="n">B_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="n">Jpadv</span><span class="o">*</span><span class="n">Wlocalpadv</span><span class="p">)</span>
                    <span class="n">small</span> <span class="o">=</span> <span class="mf">1e-2</span>
                    <span class="c1"># convert to double here</span>
                    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span> <span class="n">BB</span><span class="o">.</span><span class="n">double</span><span class="p">()</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">BB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">BB</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">*</span><span class="n">small</span><span class="p">,</span><span class="n">BJ</span><span class="o">.</span><span class="n">double</span><span class="p">())</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">fAphiIpadv</span> <span class="o">=</span> <span class="p">(</span><span class="n">B_</span><span class="nd">@coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                 <span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> 
                                                 <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># reverse this permutation (1,3,5,2,4,6,0)</span>
                <span class="n">fAphiIpad_</span> <span class="o">=</span> <span class="n">fAphiIpadv</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>        
                <span class="n">fAphiIpad</span> <span class="o">=</span> <span class="n">fAphiIpad_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                              <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> 
                                              <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> 
                                              <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="n">fAphiI</span> <span class="o">=</span> <span class="n">fAphiIpad</span><span class="p">[:,:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>


        <span class="k">else</span><span class="p">:</span> <span class="c1"># with slice matching I need to solve these equation for every slice</span>
            <span class="c1"># so far it looks like it is exactly the same as the above</span>
            <span class="c1"># I need to update</span>
            <span class="c1"># TODO</span>
            <span class="c1"># recall B_ is size nvoxels by nchannels</span>
            <span class="n">B_</span> <span class="o">=</span> <span class="n">B_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">B_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
           
            
            
            <span class="c1"># now be is nslices x npixels x nchannels B</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="c1"># multiply by weight                </span>
                <span class="n">B__</span> <span class="o">=</span> <span class="n">B_</span><span class="o">*</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">WM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>     
                <span class="c1"># B__ is shape nslices x npixels x nchannelsB</span>
                <span class="n">BB</span> <span class="o">=</span> <span class="n">B__</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="nd">@B_</span>
                <span class="c1"># BB is shape nslices x nchannelsb x nchannels b</span>
                
                <span class="n">J_</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>        
                <span class="c1"># J_ is shape nslices x npixels x nchannelsJ</span>
                <span class="c1"># B__.T is shape nslices x nchannelsB x npixels</span>
                <span class="n">BJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">B__</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">@</span> <span class="n">J_</span>
                <span class="c1"># BJ is shape nslices x nchannels B x nchannels J</span>
                <span class="c1"># TODO: add identity to BB</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">BB</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">BB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">BB</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">BB</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">BB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">BB</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span> <span class="o">@</span> <span class="n">BJ</span>
                <span class="c1"># coeffs is shape nslices x nchannelsB x nchannelsJ</span>
                
                      
            <span class="n">fAphiI</span> <span class="o">=</span> <span class="p">(</span><span class="n">B_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span><span class="nd">@coeffs</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            
        
        <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">fAphiI</span> <span class="o">-</span> <span class="n">J</span><span class="p">)</span>
        <span class="n">err2</span> <span class="o">=</span> <span class="p">(</span><span class="n">err</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">))</span>
        <span class="c1"># most of my updates are below (at the very end), but I&#39;ll update this here because it is in my cost function</span>
        <span class="c1"># note that in my derivation, the sigmaM should have this factor of DJ</span>
        <span class="n">sseM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">err2</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">update_sigmaM</span><span class="p">:</span>
            <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sseM</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">))</span><span class="c1">#*DJ</span>
        
        <span class="n">sigmaMsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmaM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">JmmuA2</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">muA</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">JmmuB2</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">muB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">n_e_step</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>                                
                <span class="k">if</span> <span class="n">update_priors</span><span class="p">:</span>
                    <span class="n">priors</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WA</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WB</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">]</span>                         
                
                <span class="n">WM</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigmaM</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>  <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaM</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="p">)</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">WA</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigmaA</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>  <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuA2</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaA</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="p">)</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">WB</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigmaB</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>  <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuB2</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="p">)</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">WS</span> <span class="o">=</span> <span class="n">WM</span><span class="o">+</span><span class="n">WA</span><span class="o">+</span><span class="n">WB</span>                
                <span class="n">WS</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">WS</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-12</span> <span class="c1"># for numerical stability, but this may be leading to issues</span>
                <span class="n">WM</span> <span class="o">/=</span> <span class="n">WS</span>
                <span class="n">WA</span> <span class="o">/=</span> <span class="n">WS</span>
                <span class="n">WB</span> <span class="o">/=</span> <span class="n">WS</span>
                <span class="c1"># todo think gabout MAP EM instead of ML EM, some dirichlet prior                </span>
                <span class="c1"># note, I seem to be getting black in my mask, why would it be black?</span>
                



        <span class="c1"># matching cost        </span>
        <span class="c1"># note the N here is the number of pixels (actually the sum of W0)</span>
        <span class="k">if</span> <span class="n">update_sigmaM</span><span class="p">:</span>
            <span class="c1"># log det sigma, when it is unknown</span>
            <span class="n">EM</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sigmaM</span><span class="p">))</span>
            <span class="c1"># Note in my derivation sigmaM is defined with a factor of prod dJ at the end</span>
            <span class="c1"># but everywhere it is used, except here, it gets divided by that factor</span>
            <span class="c1"># here including the factor just becomes another term in the sum, so I don&#39;t think I actually need it anywhere</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sum of squares when it is known (note sseM includes weights)</span>
            <span class="n">EM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sseM</span><span class="o">/</span><span class="n">sigmaM</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">DJ</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="c1"># here I have a DJ</span>
        
        
        <span class="c1"># reg cost (note that with no complex, there are two elements on the last axis)</span>
        <span class="n">version_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">version_num</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">vhat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#vhat = torch.view_as_real(torch.fft.fftn(v,dim=3,norm=&quot;backward&quot;))</span>
            <span class="c1"># dec 14, I don&#39;t think the above is correct, need to tform over dim 2,3,4 (zyx)</span>
            <span class="c1"># note that &quot;as real&quot; gives real and imaginary as a last index</span>
            <span class="n">vhat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">view_as_real</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
        
        <span class="n">ER</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vhat</span><span class="o">**</span><span class="mi">2</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">LL</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span><span class="o">/</span><span class="n">nt</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaR</span><span class="o">**</span><span class="mi">2</span>
        

        <span class="c1"># total cost </span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">EM</span> <span class="o">+</span> <span class="n">ER</span>
        

        <span class="c1"># gradient</span>
        <span class="n">E</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># covector to vector</span>
        <span class="k">if</span> <span class="n">version_num</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">vgrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">KK</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1">#vgrad = torch.view_as_real(torch.fft.ifftn(torch.fft.fftn(v.grad,dim=3,norm=&quot;backward&quot;)*(KK),</span>
            <span class="c1">#    dim=3,norm=&quot;backward&quot;))</span>
            <span class="c1">#vgrad = vgrad[...,0]</span>
            <span class="c1"># dec 14, 2021 I don&#39;t think the above is correct, re dim</span>
            <span class="n">vgrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">KK</span><span class="p">),</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
            
        <span class="c1"># Agrad = (gi@(A.grad[:3,:4].reshape(-1).to(dtype=torch.double))).reshape(3,4)</span>
        <span class="n">Agrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">grad</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="c1"># A2dgrad = (g2di@(A2d.grad[:,:2,:3].reshape(A2d.shape[0],6,1).to(dtype=torch.double))).reshape(A2d.shape[0],2,3)</span>
            <span class="n">A2dgrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">g2d</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">A2d</span><span class="o">.</span><span class="n">grad</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            

        <span class="c1"># plotting</span>
        <span class="n">Esave</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">E</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">EM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">ER</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()])</span>        
        <span class="n">Tsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">Lsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">maxvsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()))</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="n">T2dsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">L2dsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="c1"># a nice check on step size would be to see if these are oscilating or monotonic</span>
        <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">n_reduce_step</span><span class="p">:</span>
            
            <span class="n">checksign0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">checksign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">checksign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">checksign0</span> <span class="o">!=</span> <span class="n">checksign1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">checksign1</span> <span class="o">!=</span> <span class="n">checksign2</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">ev</span> <span class="o">*=</span> <span class="n">reduce_factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1"> reducing ev to </span><span class="si">{</span><span class="n">ev</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">checksign0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">checksign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">checksign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">reducedA</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">checksign0</span> <span class="o">!=</span> <span class="n">checksign1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">checksign1</span> <span class="o">!=</span> <span class="n">checksign2</span><span class="p">)):</span>
                <span class="n">eA</span> <span class="o">*=</span> <span class="n">reduce_factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">, translation oscilating, reducing eA to </span><span class="si">{</span><span class="n">eA</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">reducedA</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">checksign0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">checksign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">checksign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="p">(</span><span class="n">checksign0</span> <span class="o">!=</span> <span class="n">checksign1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">checksign1</span> <span class="o">!=</span> <span class="n">checksign2</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reducedA</span><span class="p">:</span>
                <span class="n">eA</span> <span class="o">*=</span> <span class="n">reduce_factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">, linear oscilating, reducing eA to </span><span class="si">{</span><span class="n">eA</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="c1"># to do, check sign for a2d</span>

        
        <span class="k">if</span> <span class="n">n_draw</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">n_draw</span> <span class="ow">or</span> <span class="n">it</span><span class="o">==</span><span class="n">n_iter</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1">#axE[0].plot(np.array(Esave)[:,2])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Energy&#39;</span><span class="p">)</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Matching&#39;</span><span class="p">)</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Reg&#39;</span><span class="p">)</span>


            <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figI</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminI</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxI</span><span class="p">)</span>
            <span class="n">figI</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;AphiI&#39;</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">fAphiI</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figfI</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminJ</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxJ</span><span class="p">)</span>
            <span class="n">figfI</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;fAphiI&#39;</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">fAphiI</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="o">-</span> <span class="n">J</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figErr</span><span class="p">)</span>
            <span class="n">figErr</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Err&#39;</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figJ</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminJ</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxJ</span><span class="p">)</span>
            <span class="n">figJ</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>

            <span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Tsave</span><span class="p">))</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Lsave</span><span class="p">))</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">))</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;maxv&#39;</span><span class="p">)</span>

            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sigmaMsave</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sigmaAsave</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sigmaBsave</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T2dsave</span><span class="p">))</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;T2d&#39;</span><span class="p">)</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L2dsave</span><span class="p">))</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;L2d&#39;</span><span class="p">)</span>


            <span class="n">figV</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span><span class="n">xv</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figV</span><span class="p">)</span>
            <span class="n">figV</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;velocity&#39;</span><span class="p">)</span>

            <span class="n">figW</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">,</span><span class="n">WA</span><span class="o">*</span><span class="n">W0</span><span class="p">,</span><span class="n">WB</span><span class="o">*</span><span class="n">W0</span><span class="p">)),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figW</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">figW</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Weights&#39;</span><span class="p">)</span>

            <span class="n">figE</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figI</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figfI</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figErr</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figA</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figV</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figW</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figJ</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
                <span class="n">figA2d</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>


        <span class="c1"># update</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;=</span> <span class="n">v_start</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">-=</span> <span class="n">vgrad</span><span class="o">*</span><span class="n">ev</span>
            <span class="n">v</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
            
            <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">Agrad</span><span class="o">*</span><span class="n">eA</span>
            <span class="k">if</span> <span class="n">Amode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 1 means rigid</span>
                <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">VH</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="nd">@VH</span>
            <span class="k">elif</span> <span class="n">Amode</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># 2 means rigid + scale</span>
                <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">VH</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">U</span><span class="nd">@VH</span><span class="p">)</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">Amode</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># 0 means nothing</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Amode must be 0 (normal), 1 (rigid), or 2 (rigid+scale)&#39;</span><span class="p">)</span>
            <span class="n">A</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
                
                <span class="c1"># project A to isotropic and normal up</span>
                <span class="c1"># isotropic (done)</span>
                <span class="c1"># TODO normal                </span>
                <span class="c1"># what I really should do is parameterize this group and work out a metric                                </span>
                <span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">slice_matching_isotropic</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="nd">@s@v_</span><span class="o">.</span><span class="n">T</span>               
                
                <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">slice_matching_start</span><span class="p">:</span>
                    <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">A2dgrad</span><span class="o">*</span><span class="n">eA2d</span> <span class="c1"># already scaled</span>
                <span class="c1"># project onto rigid</span>
                <span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="nd">@v_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2d</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
                
                <span class="c1"># move any xy translation into 2d</span>
                <span class="c1"># to do this I will have to account for any linear transformation</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A2di</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@vec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            

            <span class="c1"># other terms in m step, these don&#39;t actually matter until I update</span>
            <span class="n">WAW0</span> <span class="o">=</span> <span class="p">(</span><span class="n">WA</span><span class="o">*</span><span class="n">W0</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">WAW0s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WAW0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">update_muA</span><span class="p">:</span>
                <span class="n">muA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">J</span><span class="o">*</span><span class="n">WAW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WAW0s</span>
            <span class="k">if</span> <span class="n">update_sigmaA</span><span class="p">:</span>
                <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuA2</span><span class="o">*</span><span class="n">WAW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WAW0s</span>  <span class="p">)</span> 
            <span class="n">sigmaAsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmaA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

            <span class="n">WBW0</span> <span class="o">=</span> <span class="p">(</span><span class="n">WB</span><span class="o">*</span><span class="n">W0</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">WBW0s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WBW0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">update_muB</span><span class="p">:</span>
                <span class="n">muB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">J</span><span class="o">*</span><span class="n">WBW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WBW0s</span>
            <span class="k">if</span> <span class="n">update_sigmaB</span><span class="p">:</span>
                <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuB2</span><span class="o">*</span><span class="n">WBW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WBW0s</span><span class="p">)</span>
            <span class="n">sigmaBsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmaB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="mi">10</span><span class="p">:</span>
            <span class="c1"># todo print other info</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Finished iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
    <span class="c1"># outputs</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="n">A</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
           <span class="s1">&#39;v&#39;</span><span class="p">:</span><span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
           <span class="s1">&#39;xv&#39;</span><span class="p">:[</span><span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">]}</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A2d</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">full_outputs</span><span class="p">:</span>
        <span class="c1"># other data I may need</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;W0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">W0</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;muB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">muB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;muA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">muA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;sigmaB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;sigmaA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;sigmaM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;coeffs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="c1"># return figures</span>
        <span class="k">if</span> <span class="n">n_draw</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figA</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figE</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figI</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figfI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figfI</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figErr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figErr</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figJ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figJ</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figW</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figV&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figV</span>        
        <span class="c1"># others ...</span>
    <span class="k">return</span> <span class="n">out</span></div>




    
    
    
<span class="c1"># everything in the config will be either a list of the same length as downI</span>
<span class="c1"># or a list of length 1</span>
<span class="c1"># or a scalar </span>
<div class="viewcode-block" id="emlddmm_multiscale"><a class="viewcode-back" href="../emlddmm.html#emlddmm.emlddmm_multiscale">[docs]</a><span class="k">def</span> <span class="nf">emlddmm_multiscale</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Run the emlddmm algorithm multiple times, restarting </span>
<span class="sd">    with the results of the previous iteration. This is intended</span>
<span class="sd">    to be used to register data from coarse to fine resolution.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emlddmm parameters either as a list of length 1 (to use the same value</span>
<span class="sd">    at each iteration) or a list of length N (to use different values at </span>
<span class="sd">    each of the N iterations).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A list of emlddmm outputs (see documentation for emlddmm)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># how many levels?</span>
    <span class="c1"># note I expect downI to be either a list, or a list of lists, not numpy array</span>
    <span class="k">if</span> <span class="s1">&#39;downI&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">downI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span>        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">downI</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">nscales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">downI</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nscales</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="n">nscales</span><span class="si">}</span><span class="s1"> scales&#39;</span><span class="p">)</span>
        
        
    
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nscales</span><span class="p">):</span>
        <span class="c1"># now we have to convert the kwargs to a new dictionary with only one value</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                        
            
            <span class="c1"># general cases</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># not a list, e.g. inputing v as a numpy array</span>
                <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span>            
        
        <span class="k">if</span> <span class="s1">&#39;sigmaM&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;sigmaM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;sigmaB&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;sigmaB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mf">2.0</span>
        <span class="k">if</span> <span class="s1">&#39;sigmaA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;sigmaA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mf">5.0</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">emlddmm</span><span class="p">(</span><span class="n">v_res_factor</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>      
                        <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># I should save an output at each iteration</span>
        <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="s1">&#39;slice_matching&#39;</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;slice_matching&#39;</span><span class="p">]:</span>
            <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A2d</span>
        
    <span class="k">return</span> <span class="n">outputs</span> <span class="c1"># should I return the whole list outputs?</span></div>

    
<span class="c1"># we need to output the transformations as vtk, with their companion jsons (TODO)</span>
<span class="c1"># note Data with implicit topology (structured data such as vtkImageData and vtkStructuredGrid) </span>
<span class="c1"># are ordered with x increasing fastest, then y,thenz .</span>
<span class="c1"># this is notation, it means they expect first index fastest in terms of their notation</span>
<span class="c1"># I am ignoring the names xyz, and just using fastest to slowest</span>
<span class="c1"># note dataTypeis  one  of  the  types</span>
<span class="c1"># bit,unsigned_char,char,unsigned_short,short,unsigned_int,int,unsigned_long,long,float,ordouble.</span>
<span class="c1"># I should only need the latter 2</span>
<span class="n">dtypes</span> <span class="o">=</span> <span class="p">{</span>    
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span><span class="s1">&#39;float&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">):</span><span class="s1">&#39;double&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_char&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_short&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_int&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_long&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">):</span><span class="s1">&#39;char&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">):</span><span class="s1">&#39;short&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">):</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">):</span><span class="s1">&#39;long&#39;</span><span class="p">,</span>
    <span class="p">}</span>


<div class="viewcode-block" id="write_vtk_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_vtk_data">[docs]</a><span class="k">def</span> <span class="nf">write_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    Write data as vtk file legacy format file. Note data is written in big endian.</span>
<span class="sd">    </span>
<span class="sd">    inputs should be numpy, but will check for tensor</span>
<span class="sd">    only structured points supported, scalars or vectors data type</span>
<span class="sd">    each channel is saved as a dataset (time for velocity field, or image channel for images)</span>
<span class="sd">    each channel is saved as a structured points with a vector or a scalar at each point        </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        filename to write to</span>
<span class="sd">    x : list of arrays</span>
<span class="sd">        Voxel locations along last three axes</span>
<span class="sd">    out : numpy array</span>
<span class="sd">        Imaging data to write out. If out is size nt x 3 x slices x height x width we assume vector</span>
<span class="sd">        if out is size n x slices x height x width we assume scalar     </span>
<span class="sd">    title : str</span>
<span class="sd">        Name of the dataset</span>
<span class="sd">    names : list of str or None</span>
<span class="sd">        List of names for each dataset or None to use a default.        </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;VECTORS&#39;</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;SCALARS&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;out is not the right size&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;data_</span><span class="si">{</span><span class="n">t</span><span class="si">:</span><span class="s1">03d</span><span class="si">}</span><span class="s1">(b)&#39;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># make sure we know it is big endian</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">if</span> <span class="s1">&#39;(b)&#39;</span> <span class="ow">in</span> <span class="n">n</span> <span class="k">else</span> <span class="n">n</span><span class="o">+</span><span class="s1">&#39;(b)&#39;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        
        

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>        
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">([</span>
            <span class="s1">&#39;# vtk DataFile Version 3.0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="n">title</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;BINARY</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;DATASET STRUCTURED_POINTS</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;DIMENSIONS </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;ORIGIN </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;SPACING </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;POINT_DATA </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>                  
            <span class="p">])</span>
    
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;at&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">([</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">type_</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dtypes</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># make sure big endian </span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s1">&#39;VECTORS&#39;</span><span class="p">:</span>
                <span class="c1"># put the vector component at the end</span>
                <span class="c1"># on march 29, 2022, daniel flips zyx to xyz</span>
                <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;LOOKUP_TABLE default</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
                <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">outtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">out_</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">outtype</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;at&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">([</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">])</span></div>
            
<span class="n">dtypes_reverse</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;float&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">),</span>
    <span class="s1">&#39;double&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_char&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_short&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_int&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_long&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">),</span>
    <span class="s1">&#39;char&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">),</span>
    <span class="s1">&#39;short&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">),</span>
    <span class="s1">&#39;int&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">),</span>
    <span class="s1">&#39;long&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span>
<span class="p">}</span>    
<div class="viewcode-block" id="read_vtk_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_vtk_data">[docs]</a><span class="k">def</span> <span class="nf">read_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">endian</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read vtk structured points legacy format data.</span>
<span class="sd">    </span>
<span class="sd">    Note endian should always be big, but we support little as well.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Name of .vtk file to read.</span>
<span class="sd">    endian : str</span>
<span class="sd">        Endian of data, with &#39;b&#39; for big (default and only officially supported format)</span>
<span class="sd">        or &#39;l&#39; for little (for compatibility if necessary).</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        Location of voxels along each spatial axis (last 3 axes)</span>
<span class="sd">    images : numpy array</span>
<span class="sd">        Image with last three axes corresponding to spatial dimensions.  If 4D,</span>
<span class="sd">        first axis is channel.  If 5D, first axis is time, and second is xyz </span>
<span class="sd">        component of vector field.    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># TODO support skipping blank lines</span>
    <span class="n">big</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">endian</span><span class="o">==</span><span class="s1">&#39;l&#39;</span><span class="p">)</span>
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>        
        <span class="c1"># first line should say vtk version</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;vtk datafile&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;first line should include vtk DataFile Version X.X&#39;</span><span class="p">)</span>
        <span class="c1"># second line says title    </span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">line</span>

        <span class="c1"># third line should say type of data</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;BINARY&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only BINARY data type supported, but this file contains </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">data_format</span> <span class="o">=</span> <span class="n">line</span>

        <span class="c1"># next line says type of data</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;DATASET STRUCTURED_POINTS&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only STRUCTURED_POINTS dataset supported, but this file contains </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">line</span>

        <span class="c1"># next line says dimensions    </span>
        <span class="c1"># &quot;ordered with x increasing fastest, theny,thenz&quot;</span>
        <span class="c1"># this is the same as nrrd (fastest to slowest)</span>
        <span class="c1"># however our convention in python that we use channel z y x order</span>
        <span class="c1"># i.e. the first is channel</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only datasets with 3 or 4 axes supported, but this file contains </span><span class="si">{</span><span class="n">dimensions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># next says origin</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="c1"># next says spacing</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="c1"># now I can build axes</span>
        <span class="c1"># note I have to reverse the order for python</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="o">+</span><span class="n">o</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">spacing</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">origin</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># next line must contain point_data</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;POINT_DATA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;only POINT_DATA supported but this file contains </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>                          
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># now we will loop over available datasets</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="c1"># first line contains data type (scalar or vector), name, and format</span>
            <span class="c1"># it could be a blank line</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>        
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span> <span class="c1"># check if we&#39;ve reached the end of the file</span>
                <span class="k">break</span>
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;starting to load dataset </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>            
            <span class="n">S_V</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">S_V</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SCALARS&#39;</span><span class="p">,</span><span class="s1">&#39;VECTORS&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only scalars or vectors supported but this file contains </span><span class="si">{</span><span class="n">S_V</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>        
            
            <span class="k">if</span> <span class="s1">&#39;(b)&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">big</span><span class="p">:</span> 
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Note (b) symbol not in data name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">, you should check that it was written big endian. Specify endian=&quot;l&quot; if you want little&#39;</span><span class="p">)</span>
                            
            <span class="n">dtype_numpy</span> <span class="o">=</span> <span class="n">dtypes_reverse</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">big</span><span class="p">:</span>
                <span class="n">dtype_numpy_big</span> <span class="o">=</span> <span class="n">dtype_numpy</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span> <span class="c1"># &gt; means big endian</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype_numpy_big</span> <span class="o">=</span> <span class="n">dtype_numpy</span>
            <span class="c1">#</span>
            <span class="c1"># read the data</span>
            <span class="k">if</span> <span class="n">S_V</span> <span class="o">==</span> <span class="s1">&#39;SCALARS&#39;</span><span class="p">:</span>
                <span class="c1"># there should be a line with lookup table</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dtype_numpy_big</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_numpy</span><span class="p">)</span>
                <span class="c1"># shape it</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># axis order is already correct because of slowest to fastest convention in numpy</span>

            <span class="k">elif</span> <span class="n">S_V</span> <span class="o">==</span> <span class="s1">&#39;VECTORS&#39;</span><span class="p">:</span>            
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dtype_numpy_big</span><span class="p">,</span><span class="n">N</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_numpy</span><span class="p">)</span>
                <span class="c1"># shape it</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
                <span class="c1"># move vector components first</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                <span class="c1"># with vector data we should flip xyz (file) to zyx (python) (added march 29)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="c1"># stack on axis 0</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span></div>
    
    
<div class="viewcode-block" id="read_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_data">[docs]</a><span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read array data from several file types.</span>
<span class="sd">    </span>
<span class="sd">    This function will read array based data of several types</span>
<span class="sd">    and output x,images,title,names. Note we prefer vtk legacy format, </span>
<span class="sd">    but accept some other formats as read by nibabel.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename (full path or relative) of array data to load. Can be .vtk or </span>
<span class="sd">        nibabel supported formats (e.g. .nii)</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Keyword parameters that are passed on to the loader function</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        Pixel locations where each element of the list identifies pixel</span>
<span class="sd">        locations in corresponding axis.</span>
<span class="sd">    images : numpy array</span>
<span class="sd">        Imaging data of size channels x slices x rows x cols, or of size</span>
<span class="sd">        time x 3 x slices x rows x cols for velocity fields</span>
<span class="sd">    title : str</span>
<span class="sd">        Title of the dataset (read from vtk files)        </span>
<span class="sd">    names : list of str</span>
<span class="sd">        Names of each dataset (channel or time point)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># find the extension</span>
    <span class="c1"># if no extension use slice reader</span>
    <span class="c1"># if vtk use our reader</span>
    <span class="c1"># if nrrd use nrrd</span>
    <span class="c1"># otherwise try nibabel</span>
    <span class="n">base</span><span class="p">,</span><span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.gz&#39;</span><span class="p">:</span>
        <span class="n">base</span><span class="p">,</span><span class="n">ext_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext_</span><span class="o">+</span><span class="n">ext</span>
    <span class="c1">#print(f&#39;Found extension {ext}&#39;)</span>
    
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span> <span class="o">=</span> <span class="n">load_slices</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xJ</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span><span class="p">[</span><span class="kc">None</span><span class="p">]))</span>
        <span class="c1"># set the names, I will separate out mask later</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span><span class="s1">&#39;green&#39;</span><span class="p">,</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;slice_dataset&#39;</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.nrrd&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;opening with nrrd&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;NRRD not currently supported&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.tiff&#39;</span><span class="p">,</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span><span class="s1">&#39;.jpeg&#39;</span><span class="p">,</span><span class="s1">&#39;.png&#39;</span><span class="p">]:</span>
        <span class="c1"># 2D image file, I can specify dx and ox</span>
        <span class="c1"># or I can search for a companion file</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;opening 2D image file&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s1">&#39;ox&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No geometry information provided&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Searching for geometry information files&#39;</span><span class="p">)</span>
            <span class="n">json_name</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span><span class="s1">&#39;.json&#39;</span><span class="p">)</span>
            <span class="n">geometry_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;geometry.csv&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">json_name</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found json sidecar&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;json reader for single slice not implemented yet&#39;</span><span class="p">)</span>            
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">geometry_name</span><span class="p">):</span>                
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found legacy geometry file&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">geometry_name</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                            <span class="c1">#print(line)</span>
                            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                            <span class="c1"># filename, nx,ny,nz,dx,dy,dz,ox,oy,oz</span>
                            <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]])</span>
                            <span class="c1">#print(nx)</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]])</span>
                            <span class="c1">#print(dx)</span>
                            <span class="n">ox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">10</span><span class="p">]])</span>
                            <span class="c1">#print(ox)</span>
                            <span class="c1"># change xyz to zyx</span>
                            <span class="n">nx</span> <span class="o">=</span> <span class="n">nx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">ox</span> <span class="o">=</span> <span class="n">ox</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span>
                            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ox&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ox</span>                                            
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;did not found geomtry info, using some defaults&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Voxel size dx not in keywords, using (1,1,1)&#39;</span><span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;ox&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Origin not in keywords, using 0 for z, and image center for xy&#39;</span><span class="p">)</span>
            <span class="n">ox</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.tiff&#39;</span><span class="p">]:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c1"># convert to float</span>
        <span class="k">if</span> <span class="n">images</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="mf">255.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># this may do nothing if it is already float</span>
        
        <span class="c1"># add leading dimensions and reshape, note offset may be none in dims 1 and 2.</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nI</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nI</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">+=</span> <span class="n">ox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nI</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">+=</span> <span class="n">ox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">]</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>            
        
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Opening with nibabel, note only 3D images supported&#39;</span><span class="p">)</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">images</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_base_affine</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])),</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Only support diagonal affine matrix with nibabel&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span></div>
<div class="viewcode-block" id="write_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_data">[docs]</a><span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">base</span><span class="p">,</span><span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.gz&#39;</span><span class="p">:</span>
        <span class="n">base</span><span class="p">,</span><span class="n">ext_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext_</span><span class="o">+</span><span class="n">ext</span>
    <span class="c1">#print(f&#39;Found extension {ext}&#39;)</span>
    
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
        <span class="n">write_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.nii&#39;</span> <span class="ow">or</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.nii.gz&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Only grayscale images supported in nii format&#39;</span><span class="p">)</span>
            
        <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
        <span class="n">nibabel</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>  
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Writing image in nii fomat, no title or names saved&#39;</span><span class="p">)</span>

        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Only vtk and .nii/.nii.gz outputs supported&#39;</span><span class="p">)</span></div>
        
    

<div class="viewcode-block" id="write_matrix_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_matrix_data">[docs]</a><span class="k">def</span> <span class="nf">write_matrix_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write linear transforms as matrix text file.</span>
<span class="sd">    Note that in python we use zyx order, </span>
<span class="sd">    but we write outputs in xyz order</span>
<span class="sd">    </span>
<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename to write</span>
<span class="sd">    A : 2D array</span>
<span class="sd">        Matrix data to write. Assumed to be in zyx order.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># copy the matrix</span>
    <span class="n">A_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">A_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    
    <span class="c1"># swap zyx -&gt; xyz, accounting for affine</span>
    <span class="n">A_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A_</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>                
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">A_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">A_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="read_matrix_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_matrix_data">[docs]</a><span class="k">def</span> <span class="nf">read_matrix_data</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read linear transforms as matrix text file.</span>
<span class="sd">    Note in python we work in zyx order, but text files are in xyz order</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : array</span>
<span class="sd">        matrix in zyx order</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>            
            <span class="k">if</span> <span class="s1">&#39;,&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># we expect this to be a csv</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># it may be separated by spaces</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># if it is 3x3, then i is 3</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># swap xyz -&gt; zyx, accounting for affine</span>
    <span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># make copy to avoid negative strides</span></div>



<span class="c1"># write vtk point data</span>
<div class="viewcode-block" id="write_vtk_polydata"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_vtk_polydata">[docs]</a><span class="k">def</span> <span class="nf">write_vtk_polydata</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">points</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">connectivity_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    points should by Nx3 in zyx order</span>
<span class="sd">    It will be written out in xyz order</span>
<span class="sd">    connectivity should be lists of indices or nothing to write only cell data</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename to write</span>
<span class="sd">    name : str</span>
<span class="sd">        Dataset name</span>
<span class="sd">    points : array</span>
<span class="sd">        </span>
<span class="sd">    connectivity : str</span>
<span class="sd">        Array of arrays storing each connectivity element as integers that refer to the points, </span>
<span class="sd">        size number of points by number of dimensions (expected to be 3)</span>
<span class="sd">    connectivity_type : str</span>
<span class="sd">        Can by VERTICES, or POLYGONS, or LINES</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nothing</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># first we&#39;ll open the file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# vtk DataFile Version 2.0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ASCII</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DATASET POLYDATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;POINTS </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> float</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                 
        <span class="k">if</span> <span class="p">(</span><span class="n">connectivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">connectivity_type</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;VERTICES&#39;</span><span class="p">):</span>
            <span class="c1"># lets try to add vertices</span>
            <span class="c1"># the second number is how many numbers are below</span>
            <span class="c1"># there is one extra number per line</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;VERTICES </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;1 </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">connectivity_type</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;POLYGONS&#39;</span><span class="p">:</span>
            <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="n">ntot</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">ntot</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;POLYGONS </span><span class="si">{</span><span class="n">nlines</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">ntot</span><span class="o">+</span><span class="n">nlines</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">connectivity_type</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;LINES&#39;</span><span class="p">:</span>
            <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="n">ntot</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">ntot</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LINES </span><span class="si">{</span><span class="n">nlines</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">ntot</span><span class="o">+</span><span class="n">nlines</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>
                

<div class="viewcode-block" id="read_vtk_polydata"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_vtk_polydata">[docs]</a><span class="k">def</span> <span class="nf">read_vtk_polydata</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read ascii vtk polydata from simple legacy files.</span>
<span class="sd">    Assume file contains xyz order, they are converted to zyx for python</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The name of the file to read</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    points : numpy float array</span>
<span class="sd">        nx3 array storing locations of points</span>
<span class="sd">    connectivity : list of lists</span>
<span class="sd">        list of indices containing connectivity elements</span>
<span class="sd">    connectivity_type : str</span>
<span class="sd">        VERTICES or LINES or POLYGONS</span>
<span class="sd">    name : str</span>
<span class="sd">        name of the dataset</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">connectivity_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">point_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">connectivity_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># this line has name</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;POINTS&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                <span class="c1">#print(f&#39;found points {line}&#39;)</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># not using</span>
                <span class="n">point_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">point_counter</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">point_counter</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())]))</span> <span class="c1"># xyz -&gt; zyx</span>
                <span class="n">point_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">point_counter</span> <span class="o">==</span> <span class="n">npoints</span><span class="p">:</span>
                    <span class="n">point_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                    <span class="k">continue</span>
                    
            <span class="k">if</span> <span class="n">point_counter</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">connectivity_counter</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>                
                <span class="c1"># next line should say connectivity type</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">connectivity_type</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># next number should say number of connectivity entries</span>
                <span class="n">n_elements</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">n_indices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">connectivity_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">connectivity_counter</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">connectivity_counter</span> <span class="o">&lt;</span> <span class="n">n_elements</span><span class="p">:</span>
                <span class="c1"># the first number specifies how many numbers follow</span>
                <span class="n">connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>
            
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">points</span><span class="p">),</span><span class="n">connectivity</span><span class="p">,</span><span class="n">connectivity_type</span><span class="p">,</span><span class="n">name</span></div>
                

<span class="c1"># write outputs</span>
<div class="viewcode-block" id="write_transform_outputs"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_transform_outputs">[docs]</a><span class="k">def</span> <span class="nf">write_transform_outputs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">src_space</span><span class="p">,</span> <span class="n">dest_space</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">src_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write transforms output from emlddmm.  Velocity field, 3D affine transform,</span>
<span class="sd">    and 2D affine transforms for each slice if applicable.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Directory to place output data (will be created of it does not exist)</span>
<span class="sd">    output : dict</span>
<span class="sd">        Output dictionary from emlddmm algorithm</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">slice_outputs</span> <span class="o">=</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">output</span>
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>

    <span class="n">device</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">device</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span>


    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">slice_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;json&#39;</span><span class="p">]</span>
        <span class="n">slice_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">slice_names</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>
        <span class="n">registered_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED/</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED/transforms&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">registered_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">registered_dir</span><span class="p">)</span>
        <span class="n">input_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT/</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT/transforms&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">registered_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED_</span><span class="si">{</span><span class="n">slice_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT_</span><span class="si">{</span><span class="n">slice_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_matrix.txt&#39;</span><span class="p">)</span>
            <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">A2d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT_</span><span class="si">{</span><span class="n">slice_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED_</span><span class="si">{</span><span class="n">slice_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_matrix.txt&#39;</span><span class="p">)</span>
            <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">forward_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED_to_</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">)</span>

        <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">,</span> <span class="s1">&#39;velocity.vtk&#39;</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;velocity_field&#39;</span>
        <span class="n">write_vtk_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="n">title</span><span class="p">)</span>

        <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">,</span> <span class="s1">&#39;A.txt&#39;</span><span class="p">)</span>
        <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">forward_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">)</span>

        <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">,</span> <span class="s1">&#39;velocity.vtk&#39;</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;velocity_field&#39;</span>
        <span class="n">write_vtk_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="n">title</span><span class="p">)</span>

        <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">forward_dir</span><span class="p">,</span> <span class="s1">&#39;A.txt&#39;</span><span class="p">)</span>
        <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="write_qc_outputs"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_qc_outputs">[docs]</a><span class="k">def</span> <span class="nf">write_qc_outputs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">src_space</span><span class="p">,</span> <span class="n">src_img</span><span class="p">,</span> <span class="n">dest_space</span><span class="p">,</span> <span class="n">dest_img</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">xJ</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">src_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Write outputs</span>
<span class="sd">    TODO figure out how to do this with or without A2d</span>
<span class="sd">    I still want to output per slice</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">xv</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    
    
    <span class="c1"># </span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">device</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span>
    
    <span class="c1"># to torch</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># segmentations go with atlas, they are integers</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> 
        <span class="c1"># don&#39;t specify dtype here, you had better set it in numpy</span>
        <span class="c1"># actually I need it as float in order to apply interp</span>
        <span class="k">if</span> <span class="n">xS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xS</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
            
    <span class="n">slice_matching</span> <span class="o">=</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">output</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>

    <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="c1"># TODO: clean up later</span>
    <span class="c1"># output_dir = os.path.join(output_dir,&#39;qc/&#39;)</span>
    <span class="c1"># if not os.path.isdir(output_dir):</span>
    <span class="c1">#     os.mkdir(output_dir)</span>
    <span class="c1"># print(f&#39;output dir is {output_dir}&#39;)</span>
    
    <span class="c1"># first, lets see the transformed atlas and target    </span>
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xJ</span><span class="p">))</span>    
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>        
        <span class="n">XJ_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJ</span><span class="p">)</span>            
        <span class="n">XJ_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">XJ_</span> <span class="o">=</span> <span class="n">XJ</span>

    <span class="c1"># sample points for affine</span>
    <span class="n">Xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ_</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># for diffeomorphism</span>
    <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">))</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
    <span class="n">phiiAi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs</span>

    <span class="c1"># transform image</span>
    <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phiiAi</span><span class="p">)</span>

    <span class="c1"># print(&#39;J shape: &#39;, J.shape)</span>
    <span class="c1"># print(&#39;AphiI shape: &#39;, AphiI.shape)       </span>

    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">to_input_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT/</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_INPUT/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">to_input_out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_input_out</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;output dir is </span><span class="si">{</span><span class="n">to_input_out</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1"> input&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_input_out</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1">_input.jpg&#39;</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_input_out</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">to_src_space_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">to_src_space_out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_src_space_out</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;output dir is </span><span class="si">{</span><span class="n">to_src_space_out</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_src_space_out</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1"> Original&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_src_space_out</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1">_original.jpg&#39;</span><span class="p">)</span>

    <span class="c1">#fig = draw(torch.cat((AphiI,J,AphiI),0),xJ)</span>
    <span class="c1">#fig[0].suptitle(&#39;Input Space&#39;)</span>
    
    
    <span class="c1"># first we need to build the reconstructed space</span>
    <span class="c1"># this is only done if there is 2D</span>
    <span class="c1"># maybe I should have reorientation at least otherwise? Not yet</span>
    <span class="c1"># that is, only apply the 2D transforms</span>
    <span class="c1"># then I can</span>
    <span class="c1"># I&#39;ll have to build an intelligent sample space</span>
    <span class="c1"># because they may be shifted out of their original volumes</span>
    <span class="c1"># to do this we&#39;ll apply A2di to the corners of each slice</span>
    <span class="c1"># and get the min and max</span>
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xJ</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@XJ</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">M0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">M1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># construct a recon domain</span>
        <span class="n">dJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
        <span class="n">xr0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">M0</span><span class="p">),</span><span class="n">dJ</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">xr1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">m1</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">M1</span><span class="p">),</span><span class="n">dJ</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xr0</span><span class="p">,</span><span class="n">xr1</span>
        <span class="n">XR</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xr</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># now we have to sample J at A Xr</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XR</span><span class="p">)</span>
        <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@XR</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Jr</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Jr</span><span class="p">,</span><span class="n">xr</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1"> Registered&#39;</span><span class="p">)</span>
        <span class="n">to_registered_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED/</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">to_registered_out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_registered_out</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_registered_out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1">_registered.jpg&#39;</span><span class="p">)</span>

        <span class="c1"># and we need atlas recon</span>
        <span class="c1"># sample points for affine</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XR</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># for diffeomorphism</span>
        <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">))</span>
        <span class="n">phiiAi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs</span>

        <span class="c1"># transform image</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phiiAi</span><span class="p">)</span>       
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xr</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1"> Registered&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_registered_out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_registered.jpg&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Jr</span> <span class="o">=</span> <span class="n">J</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="n">xJ</span>


    <span class="c1">#fig = draw(torch.cat((AphiI,Jr,AphiI),0),xr)</span>
    <span class="c1">#fig[0].suptitle(&#39;Recon space&#39;)</span>
    
    <span class="c1"># and atlas space</span>
    <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xI</span><span class="p">))</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="c1">#A = LT_to_A(L.detach(),T.detach())</span>
    <span class="n">Aphi</span> <span class="o">=</span> <span class="p">((</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@phi</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">Aphi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">Aphi</span><span class="p">,</span><span class="n">XI</span><span class="p">)</span>


    <span class="n">phiiAiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xr</span><span class="p">,</span><span class="n">Jr</span><span class="p">,</span><span class="n">Aphi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">to_dest_space_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED_to_</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">to_dest_space_out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_dest_space_out</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;output dir is </span><span class="si">{</span><span class="n">to_dest_space_out</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">to_dest_space_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">to_dest_space_out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_dest_space_out</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;output dir is </span><span class="si">{</span><span class="n">to_dest_space_out</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">phiiAiJ</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_dest_space_out</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">src_img</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1"> Original&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">to_dest_space_out</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1">_original.jpg&#39;</span><span class="p">)</span>

    <span class="n">output_slices</span> <span class="o">=</span> <span class="n">slice_matching</span> <span class="ow">and</span> <span class="p">(</span> <span class="p">(</span><span class="n">xS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">output_slices</span><span class="p">:</span>
        <span class="c1"># transform S</span>
        <span class="c1"># note here I had previously converted it to float</span>
        <span class="n">AphiS</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xS</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span><span class="n">phiiAi</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">mods</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">AphiS</span><span class="o">%</span><span class="n">mods</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">mods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">AphiS</span><span class="o">%</span><span class="n">mods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">mods</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">AphiS</span><span class="o">%</span><span class="n">mods</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">mods</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">)),</span><span class="n">xr</span><span class="p">)</span>

        <span class="c1"># also outlines</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">AphiS</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1">#range(-r,r+1): # in the coronal plane my M is &quot;nice&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">AphiS</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">!=</span><span class="n">AphiS</span><span class="p">)</span>
        <span class="c1">#fig = draw(M[None])</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">))</span><span class="o">*</span><span class="n">M</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.99</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="n">q</span><span class="p">)</span>
        <span class="n">Jn</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jr</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Jn</span><span class="p">[</span><span class="n">Jn</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Jn</span><span class="p">[</span><span class="n">Jn</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">show_</span> <span class="o">=</span> <span class="n">Jn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">alpha</span>


        <span class="c1">#fig = plt.figure(figsize=(8,10))</span>
        <span class="c1">#draw(show_,n_slices=3,fig=fig)</span>

        <span class="c1">#f,ax = plt.subplots()</span>
        <span class="c1">#ax.imshow(show_[:,show.shape[1]//2].transpose(1,2,0))</span>
        
        <span class="c1"># get slice names</span>
        <span class="n">slice_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;json&#39;</span><span class="p">]</span>
        <span class="n">slice_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">slice_names</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>
        <span class="n">f</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">show_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">show_</span><span class="p">[:,</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_registered_out</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">dest_img</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">src_space</span><span class="si">}</span><span class="s1">_REGISTERED_</span><span class="si">{</span><span class="n">slice_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="Transform"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Transform">[docs]</a><span class="k">class</span> <span class="nc">Transform</span><span class="p">():</span>    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A simple class for storing and applying transforms</span>
<span class="sd">    TODO: add another type for series of 2D transforms</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># instead we load it</span>
            <span class="n">prefix</span><span class="p">,</span><span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;.txt&#39;</span><span class="p">:</span>
                <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                data = np.genfromtxt(data,delimiter=&#39;,&#39;)                </span>
<span class="sd">                # note that there are nans at the end if I have commas at the end</span>
<span class="sd">                if np.isnan(data[0,-1]):</span>
<span class="sd">                    data = data[:,:data.shape[1]-1]</span>
<span class="sd">                    #print(data)</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="c1"># note on March 29, daniel adds the following and commented out the above</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_vtk_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only txt and vtk files supported but your transform is </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">]</span>            
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Direction must be </span><span class="se">\&#39;</span><span class="s1">f</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">b</span><span class="se">\&#39;</span><span class="s1"> but it was </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        
        <span class="c1"># if it is a velocity field we need to integrate it</span>
        <span class="c1"># if it is a displacement field, then we need to add identity to it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># assume this is a displacement field and add identity</span>
                <span class="c1"># if it is a displacement field we cannot invert it, so we should throw an error if you use the wrong f,b</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assum this is a velocity field and integrate it</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Domain is required when inputting veloctiy field&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,(</span><span class="mi">0</span><span class="p">,)))</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span><span class="c1"># if it is a matrix check size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span>            
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only 3x3 or 4x4 matrices supported now but this is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># if it is a mapping</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;When specifying a mapping, backwards is not supported&#39;</span><span class="p">)</span>
        
                
                
                
<div class="viewcode-block" id="Transform.apply"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Transform.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># then it is a matrix</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@X</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># then it is a mapping, we need interp</span>
            <span class="c1"># recall all components are stored on the first axis,</span>
            <span class="c1"># but for sampling they need to be on the last axis</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>
            <span class="c1"># print(f&#39;ID shape {ID.shape}&#39;)</span>
            <span class="c1"># print(f&#39;X shape {X.shape}&#39;)</span>
            <span class="c1"># print(f&#39;data shape {self.data.shape}&#39;)</span>
            <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">ID</span><span class="p">),</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span></div>
            
        
            
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Transform with data size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">, direction </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="si">}</span><span class="s1">, and domain </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>
            
<span class="c1"># now wrap this into a function</span>
<div class="viewcode-block" id="compose_sequence"><a class="viewcode-back" href="../emlddmm.html#emlddmm.compose_sequence">[docs]</a><span class="k">def</span> <span class="nf">compose_sequence</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="n">Xin</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Input can be a list of transforms class.</span>
<span class="sd">    Or a list of filenames (single direction in argument)</span>
<span class="sd">    Or a list of a list of 2 tuples that specify direction (f,b)</span>
<span class="sd">    Or an output directory</span>
<span class="sd">    </span>
<span class="sd">    Note f is default which maps points from atlas to target, </span>
<span class="sd">    or images from target to atlas.</span>
<span class="sd">    </span>
<span class="sd">    Xin are the points we want to transform (e.g. sample points in atlas)</span>
<span class="sd">    </span>
<span class="sd">    TODO use os path join</span>
<span class="sd">    TODO support direction as a list, right now direction only is used for a single direction</span>
<span class="sd">    </span>
<span class="sd">    Note, if the input is a string, we assume it is an output directory and get A and V. In this case we use the direction argument.</span>
<span class="sd">    If the input is a tuple of length 2, we assume it is an output directory and a direction</span>
<span class="sd">    </span>
<span class="sd">    Otherwise, the input must be a list.  It can be a list of strings, or transforms, or string-direction tuples.</span>
<span class="sd">    </span>
<span class="sd">    What if it is a list of length 1?</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;starting to compose sequence with transforms </span><span class="si">{</span><span class="n">transforms</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>    
    
    
    <span class="c1"># check special case for a list of length 1 but the input is a directory</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> 
        <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># check special case for a list of length one but the input is a tuple</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> 
        <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> 
        <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">]):</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># note variable is redefined                </span>
    
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>            
        <span class="c1"># assume output directory</span>
        <span class="c1"># print(&#39;printing transforms input&#39;)</span>
        <span class="c1"># print(transforms)</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
            <span class="c1"># backward, first affine then deform</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;A.txt&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">),</span>
                          <span class="n">Transform</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;velocity.vtk&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="c1"># forward, first deform then affine</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;velocity.vtk&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">),</span>
                          <span class="n">Transform</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;A.txt&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)]</span>    
        <span class="c1">#print(&#39;printing modified transforms&#39;)</span>
        <span class="c1">#print(transforms)    </span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="c1"># there is an issue here:</span>
        <span class="c1"># when I call this from outside, the type is emlddmm.Transform, not Transform. The test fails</span>
        <span class="c1"># print(type(transforms[0]))</span>
        <span class="c1"># print(isinstance(transforms[0],Transform))</span>
        <span class="c1">#if type(transforms[0]) == Transform:</span>
        <span class="k">if</span> <span class="s1">&#39;Transform&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span> 
            <span class="c1"># this approach may fix the issue but I don&#39;t like it</span>
            <span class="c1"># I am having trouble reproducing this error on simpler examples</span>
            <span class="c1"># don&#39;t do anything here</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># list of strings</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">direction</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Transforms must be either output directory, </span><span class="se">\</span>
<span class="s1">        or list of objects, or list of filenames, </span><span class="se">\</span>
<span class="s1">        or list of tuples storing filename/direction&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Transforms must be either output directory, </span><span class="se">\</span>
<span class="s1">        or list of objects, or list of filenames, </span><span class="se">\</span>
<span class="s1">        or list of tuples storing filename/direction&#39;</span><span class="p">)</span>
    <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">Xin</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>    
    <span class="n">Xout</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">Xin</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
        <span class="n">Xout</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">Xout</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Xout</span></div>
    
<div class="viewcode-block" id="apply_transform_float"><a class="viewcode-back" href="../emlddmm.html#emlddmm.apply_transform_float">[docs]</a><span class="k">def</span> <span class="nf">apply_transform_float</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Apply transform to image</span>
<span class="sd">    Image points stored in x, data stored in I</span>
<span class="sd">    transform stored in Xout</span>
<span class="sd">    </span>
<span class="sd">    There is an issue with numpy integer arrays, I&#39;ll have two functions</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">Xout</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">Xout</span><span class="o">.</span><span class="n">device</span><span class="p">),</span><span class="n">Xout</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">isnumpy</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">AphiI</span></div>

<div class="viewcode-block" id="apply_transform_int"><a class="viewcode-back" href="../emlddmm.html#emlddmm.apply_transform_int">[docs]</a><span class="k">def</span> <span class="nf">apply_transform_int</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">,</span><span class="n">double</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Apply transform to image</span>
<span class="sd">    Image points stored in x, data stored in I</span>
<span class="sd">    transform stored in Xout</span>
<span class="sd">    </span>
<span class="sd">    There is an issue with numpy integer arrays, I&#39;ll have two functions</span>
<span class="sd">    </span>
<span class="sd">    Note that we often require double precision when converting to floats and back</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">Itype</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="s1">&#39;mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;mode must be nearest for ints&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">Xout</span><span class="o">.</span><span class="n">device</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span>
    
    <span class="c1"># for int, I need to convert to float for interpolation    </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">double</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">Xout</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span><span class="n">Xout</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">Xout</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">isnumpy</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">Itype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">AphiI</span></div>
    
            

        
<div class="viewcode-block" id="rigid2D"><a class="viewcode-back" href="../emlddmm.html#emlddmm.rigid2D">[docs]</a><span class="k">def</span> <span class="nf">rigid2D</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Rigid transformation between 2D slices.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>
        
    
<div class="viewcode-block" id="write_outputs_for_pair"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_outputs_for_pair">[docs]</a><span class="k">def</span> <span class="nf">write_outputs_for_pair</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">outputs</span><span class="p">,</span>
                           <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">WJ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">atlas_space_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">target_space_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">atlas_image_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">target_image_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write outputs in standard format for a pair of images</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Location to store output data.</span>
<span class="sd">    outputs : dict</span>
<span class="sd">        Dictionary of outputs from the emlddmm python code</span>
<span class="sd">    xI : list of numpy array</span>
<span class="sd">        Location of voxels in atlas</span>
<span class="sd">    I : numpy array</span>
<span class="sd">        Atlas image</span>
<span class="sd">    xJ : list of numpy array</span>
<span class="sd">        Location of voxels in target</span>
<span class="sd">    J : numpy array</span>
<span class="sd">        Target image</span>
<span class="sd">    names : str</span>
<span class="sd">        Names of spaces;images otherwise will use default</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">atlas_space_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atlas_space_name</span> <span class="o">=</span> <span class="s1">&#39;atlas&#39;</span>
    <span class="k">if</span> <span class="n">target_space_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_space_name</span> <span class="o">=</span> <span class="s1">&#39;target&#39;</span>
    <span class="k">if</span> <span class="n">atlas_image_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atlas_image_name</span> <span class="o">=</span> <span class="s1">&#39;atlasimage&#39;</span>
    <span class="k">if</span> <span class="n">target_image_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_image_name</span> <span class="o">=</span> <span class="s1">&#39;targetimage&#39;</span>
 
        
        
    <span class="k">if</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="n">slice_matching</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slice_matching</span> <span class="o">=</span> <span class="kc">False</span>
        
    <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span>
    <span class="n">IMAGES</span> <span class="o">=</span> <span class="s1">&#39;images&#39;</span> <span class="c1"># define some strings</span>
    <span class="n">TRANSFORMS</span> <span class="o">=</span> <span class="s1">&#39;transforms&#39;</span>
    <span class="c1"># make the output directory</span>
    <span class="c1"># note this function will do it recursively even if it exists</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># to atlas space</span>
    <span class="n">to_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
    <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># to atlas space from atlas space </span>
    <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
    <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># to atlas space from atlas space</span>
    <span class="n">images_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># write out the atlas (in single)</span>
    <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
               <span class="n">xI</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="s1">&#39;atlas&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;not implemented yet&#39;</span><span class="p">)</span>
        <span class="c1"># to atlas space from target space    </span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to atlas space from target space transforms    </span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">)</span>
        <span class="c1"># write out the atlas to target transform as a displacement field</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if slice matching</span>
        <span class="c1"># to atlas space from registered target space</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="s1">&#39;registered_&#39;</span> <span class="o">+</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to atlas space from registered target space transforms    </span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># we need the atlas to registered displacement</span>
        <span class="c1"># this is  A phi - x</span>
        <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">],</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)))</span>
        <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">phiXI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">phi</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">XI</span><span class="p">)</span> <span class="o">+</span> <span class="n">XI</span>            
        <span class="n">AphiXI</span> <span class="o">=</span> <span class="p">((</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@phiXI</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>                
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span><span class="n">xI</span><span class="p">,(</span><span class="n">AphiXI</span><span class="o">-</span><span class="n">XI</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement&#39;</span><span class="p">)</span>
        
        <span class="c1"># to atlas space from registered space images</span>
        <span class="c1"># nothing here because no images were acquired in this space</span>
        
        
        
        <span class="c1"># to atlas space from input target space</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="s1">&#39;input_&#39;</span> <span class="o">+</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to atlas space from input target space transforms    </span>
        <span class="c1"># THESE TRANSFORMS DO NOT EXIST</span>
        <span class="c1"># to atlas space from input target space images</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to get these images I first need to map them to registered</span>
        <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]))</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
        <span class="n">RXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span><span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">RXJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">XJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">],</span><span class="n">RXJ</span><span class="p">))</span>
        <span class="n">RiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">RXJ</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">phiiAiRiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">RiJ</span><span class="p">,</span><span class="n">AphiXI</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xI</span><span class="p">,</span><span class="n">phiiAiRiJ</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># qc in atlas space</span>
        <span class="n">qc_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="s1">&#39;qc&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>        
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">phiiAiRiJ</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;phiiAiRiJ&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        
    
        <span class="c1"># now we do to registered space</span>
        <span class="n">to_space_name</span> <span class="o">=</span> <span class="s1">&#39;registered_&#39;</span> <span class="o">+</span> <span class="n">target_space_name</span>
        <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># from input</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="s1">&#39;input_&#39;</span> <span class="o">+</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># transforms, registered to input</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1">#for i in range(R.shape[0]):</span>
        <span class="c1">#    # convert to xyz</span>
        <span class="c1">#    Rxyz = torch.tensor(R[i])</span>
        <span class="c1">#    Rxyz[:2] = torch.flip(Rxyz[:2],dims=(0,))</span>
        <span class="c1">#    Rxyz[:,:2] = torch.flip(Rxyz[:,:2],dims=(1,))</span>
        <span class="c1">#    # write out</span>
        <span class="c1">#    with open(os.path.join(from_space_dir)):</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">RXJ</span><span class="o">-</span><span class="n">XJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># images</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">RiJ</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># from atlas</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># transforms, registered to atlas</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">AiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phiiAiXJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">AiXJ</span><span class="p">)</span> <span class="o">+</span> <span class="n">AiXJ</span>                
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">phiiAiXJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># images</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phiiAiXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phiiAiXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">phiiAiXJ</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">AphiI</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># a qc directory</span>
        <span class="n">qc_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="s1">&#39;qc&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">RiJ</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;RiJ&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span>
                                 <span class="sa">f</span><span class="s1">&#39;input_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_registered_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;AphiI&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span>
                                 <span class="sa">f</span><span class="s1">&#39;input_</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_registered_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        
        
        <span class="c1"># to input space</span>
        <span class="n">to_space_name</span> <span class="o">=</span> <span class="s1">&#39;input_&#39;</span> <span class="o">+</span> <span class="n">target_space_name</span>
        <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># input to input</span>
        <span class="c1"># TODO: i can write the original images here</span>
        
        <span class="c1"># registered to input</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="s1">&#39;registered_&#39;</span> <span class="o">+</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># images, NONE        </span>
        <span class="c1"># transforms</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">Ri</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">])</span>
        <span class="n">RiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span><span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ri</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">RiXJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">XJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">],</span><span class="n">RiXJ</span><span class="p">))</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">RXJ</span><span class="o">-</span><span class="n">XJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        
        <span class="c1"># atlas to input</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># transforms</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">AiRiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@RiXJ</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phiiAiRiXJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">AiRiXJ</span><span class="p">)</span> <span class="o">+</span> <span class="n">AiRiXJ</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">phiiAiRiXJ</span><span class="o">-</span><span class="n">XJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># images</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">RAphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phiiAiRiXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phiiAiRiXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">phiiAiRiXJ</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">RAphiI</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># input space qc        </span>
        <span class="n">qc_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="s1">&#39;qc&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">RAphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;RAphiI&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span></div>

        
<div class="viewcode-block" id="pad"><a class="viewcode-back" href="../emlddmm.html#emlddmm.pad">[docs]</a><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Pad an image and its domain.    </span>
<span class="sd">    </span>
<span class="sd">    Perhaps include here</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Not Implemented&#39;</span><span class="p">)</span>
    <span class="k">pass</span></div>
    
<div class="viewcode-block" id="map_image"><a class="viewcode-back" href="../emlddmm.html#emlddmm.map_image">[docs]</a><span class="k">def</span> <span class="nf">map_image</span><span class="p">(</span><span class="n">emlddmm_path</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">,</span> <span class="n">from_space_name</span><span class="p">,</span> <span class="n">to_space_name</span><span class="p">,</span>
              <span class="n">input_image_fname</span><span class="p">,</span> <span class="n">output_image_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">from_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">use_detjac</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function will map imaging data from one space to another. </span>
<span class="sd">    There are four cases:</span>
<span class="sd">    1. 3D to 3D mapping: A single displacement field is used to map data</span>
<span class="sd">    2. 3D to 2D mapping: A single displacement field is used to map data, </span>
<span class="sd">        a slice filename is needed in addition to a space</span>
<span class="sd">    3. 2D to 2D mapping: A single matrix is used to map data.</span>
<span class="sd">    4. 2D to 3D mapping: Currently not supported. Ideally this will output</span>
<span class="sd">        data, and weights for a single slice, so it can be averaged with other slices.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emlddmm_path : str</span>
<span class="sd">        Path to the emlddmm python library, used for io</span>
<span class="sd">    root_dir : str</span>
<span class="sd">        The root directory of the output structure</span>
<span class="sd">    from_space_name : str</span>
<span class="sd">        The name of the space we are mapping data from</span>
<span class="sd">    to_space_name : str</span>
<span class="sd">        The name of the space we are mapping data to</span>
<span class="sd">    input_image_fname : str</span>
<span class="sd">        Filename of the input image to be transformed</span>
<span class="sd">    output_image_fname : str</span>
<span class="sd">        Filename of the output image after transformation. If None (default), it will be returned as a python variable but not written to disk.</span>
<span class="sd">    from_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    to_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    use_detjac : bool</span>
<span class="sd">        If the image represents a density, it should be transformed and multiplied by the Jacobian of the transformation</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Arguments passed to torch interpolation (grid_resample), e.g. padding_mode,</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phiI : array</span>
<span class="sd">        Transformed image</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">split</span><span class="p">,</span><span class="n">join</span><span class="p">,</span><span class="n">splitext</span>
    <span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>     
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This function is experimental&#39;</span><span class="p">)</span>
    
    <span class="c1"># first load the image to be transformed</span>
    <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)</span>    
    
    <span class="c1"># find the transformation we need, in each case I will load the appropriate data, and return a phi</span>
    <span class="n">transform_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 1, 3D to 3D</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span><span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">))</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">detjac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 2, 3D to 2D</span>
        <span class="c1"># we have a displacement field  </span>
        <span class="n">to_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">to_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">))</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>        
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Detjac not currently supported for 3D to 2D&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1"># This is case 3, 2D to 2D, we have an xyz matrix        </span>
        <span class="n">to_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">from_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">to_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">from_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_matrix.txt&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DetJac is 1 for 2D to 2D, so it is ignored&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;matrix data:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># we need to convert this to a displacement field</span>
        <span class="c1"># to do this we need some image to get sample points</span>
        <span class="c1"># we use the &quot;to&quot; slice image name</span>
        <span class="n">image_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span><span class="p">,</span><span class="s1">&#39;images&#39;</span><span class="p">)</span>
        
        <span class="n">testfile</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span><span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;*_to_*&#39;</span> <span class="o">+</span> <span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;*.vtk&#39;</span><span class="p">))</span>
        <span class="n">xS</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">testfile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xS</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="c1"># now we can build a phi</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="p">((</span><span class="n">A</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@Xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Xs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">],</span><span class="n">phi</span><span class="p">)</span> <span class="p">)</span>         
        <span class="n">xD</span> <span class="o">=</span> <span class="n">xS</span>
        
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># this is 2D to 3D we have a displacement field</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D to 3D not implemented yet, may not get implemented&#39;</span><span class="p">)</span>
    
    <span class="c1"># apply the transform to the image</span>
    <span class="c1"># if desired calculate jacobian</span>
    <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Jacobian not implemented yet for with 2D slices&#39;</span><span class="p">)</span>
        
    <span class="c1"># todo, implement when I is int</span>
    <span class="n">phiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    
    
    <span class="k">if</span> <span class="n">output_image_directory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># we need to go back to the four cases here</span>
        <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 1, 3d to 3d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_image_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            <span class="n">outtitle</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">outfname</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 2, 3d to 2d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_image_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            <span class="n">outtitle</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">outfname</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 3, 2d to 2d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_image_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            <span class="n">outtitle</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">outfname</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case 4, 2d to 3d</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D to 3D not supported&#39;</span><span class="p">)</span>
            
        <span class="c1"># a hack for slice thickness</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">20.0</span><span class="p">])</span>    
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing file with name </span><span class="si">{</span><span class="n">outfname</span><span class="si">}</span><span class="s1"> and title </span><span class="si">{</span><span class="n">outtitle</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">outfname</span><span class="p">,</span><span class="n">xD</span><span class="p">,</span><span class="n">phiI</span><span class="p">,</span><span class="n">outtitle</span><span class="p">)</span>
        
        
    <span class="k">return</span> <span class="n">xD</span><span class="p">,</span><span class="n">phiI</span></div>
    
    
        
<div class="viewcode-block" id="map_points"><a class="viewcode-back" href="../emlddmm.html#emlddmm.map_points">[docs]</a><span class="k">def</span> <span class="nf">map_points</span><span class="p">(</span><span class="n">emlddmm_path</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">,</span> <span class="n">from_space_name</span><span class="p">,</span> <span class="n">to_space_name</span><span class="p">,</span>
              <span class="n">input_points_fname</span><span class="p">,</span> <span class="n">output_points_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">from_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">use_detjac</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    For points we need to get the transforms in the opposite folder to images.</span>
<span class="sd">    </span>
<span class="sd">    This function will map imaging data from one space to another. </span>
<span class="sd">    There are four cases:</span>
<span class="sd">    1. 3D to 3D mapping: A single displacement field is used to map data</span>
<span class="sd">    2. 3D to 2D mapping: Currently not supported.</span>
<span class="sd">    3. 2D to 2D mapping: A single matrix is used to map data.</span>
<span class="sd">    4. 2D to 3D mapping: A single displacement field is used to map data, </span>
<span class="sd">        a slice filename is needed in addition to a space</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emlddmm_path : str</span>
<span class="sd">        Path to the emlddmm python library, used for io</span>
<span class="sd">    root_dir : str</span>
<span class="sd">        The root directory of the output structure</span>
<span class="sd">    from_space_name : str</span>
<span class="sd">        The name of the space we are mapping data from</span>
<span class="sd">    to_space_name : str</span>
<span class="sd">        The name of the space we are mapping data to</span>
<span class="sd">    input_points_fname : str</span>
<span class="sd">        Filename of the input image to be transformed</span>
<span class="sd">    output_directory_fname : str</span>
<span class="sd">        Filename of the output image after transformation. If None (default), it will be returned as a python variable but not written to disk.</span>
<span class="sd">    from_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    to_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    use_detjac : bool</span>
<span class="sd">        If the image represents a density, it should be transformed and multiplied by the Jacobian of the transformation</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Arguments passed to torch interpolation (grid_resample), e.g. padding_mode,</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phiP : array</span>
<span class="sd">        Transformed points</span>
<span class="sd">    connectivity : list of lists</span>
<span class="sd">        Same connectivity entries as loaded data</span>
<span class="sd">    connectivity_type : str</span>
<span class="sd">        Same connectivity type as loaded data</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">split</span><span class="p">,</span><span class="n">join</span><span class="p">,</span><span class="n">splitext</span>
    <span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>    
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This function is experimental&#39;</span><span class="p">)</span>
    
    <span class="c1"># first load the points to be transformed</span>
    <span class="n">points</span><span class="p">,</span><span class="n">connectivity</span><span class="p">,</span><span class="n">connectivity_type</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="n">read_vtk_polydata</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)</span>    
    
    <span class="c1"># find the transformation we need, in each case I will load the appropriate data, and return a phi</span>
    <span class="c1"># note that for points we use the inverse to images</span>
    <span class="c1"># transform_dir = join(root_dir,to_space_name,from_space_name + &#39;_to_&#39; + to_space_name,&#39;transforms&#39;)</span>
    <span class="c1"># above was for images</span>
    <span class="n">transform_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span><span class="n">from_space_name</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 1, 3D to 3D</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span><span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">))</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">detjac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 2, 3D to 2D</span>
        <span class="c1"># this one is not implemented</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;3D to 2D not implemented for points&#39;</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1"># This is case 3, 2D to 2D, we have an xyz matrix        </span>
        <span class="n">to_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">from_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">file_search</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">from_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">to_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_matrix.txt&#39;</span><span class="p">)</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DetJac is 1 for 2D to 2D, so it is ignored&#39;</span><span class="p">)</span>
            
        <span class="n">data</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;matrix data:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># we do not need to convert this to a displacement field</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># this is 2D to 3D we have a displacement field</span>
        <span class="n">from_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">file_search</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">from_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>        
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Detjac not currently supported for 2D to 3D&#39;</span><span class="p">)</span>
            
    
    <span class="c1"># apply the transform to the image</span>
    <span class="c1"># if desired calculate jacobian</span>
    <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Jacobian not implemented yet&#39;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">phi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># points is size N x 3</span>
        <span class="c1"># we want 3 x 1 x 1 x N</span>
        <span class="n">points_</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span>                
        <span class="n">phiP</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xD</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">points_</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phiP</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">phiP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="n">phiP</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="n">output_points_directory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1"># we need to go back to the four cases here</span>
        <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 1, 3d to 3d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_points_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 2, 3d to 2d</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;3D to 2D not supported&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 3, 2d to 2d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_points_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
                    
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case 4, 2d to 3d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_points_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            
            
         
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing file with name </span><span class="si">{</span><span class="n">outfname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_vtk_polydata</span><span class="p">(</span><span class="n">outfname</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">phiP</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span><span class="n">connectivity_type</span><span class="o">=</span><span class="n">connectivity_type</span><span class="p">)</span>
        
        
    <span class="k">return</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">connectivity_type</span><span class="p">,</span> <span class="n">name</span></div>
    
    
        
    
        
<span class="c1"># now we&#39;ll start building an interface</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># set up command line args</span>
    <span class="c1"># we will either calculate mappings or apply mappings</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Calculate or apply mappings, or run a specified pipeline.&#39;</span><span class="p">,</span> <span class="n">epilog</span><span class="o">=</span><span class="s1">&#39;Enjoy&#39;</span><span class="p">)</span>
    
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-m&#39;</span><span class="p">,</span><span class="s1">&#39;--mode&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify mode as one of register, transform, or a named pipeline&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;register&#39;</span><span class="p">,</span><span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;register&#39;</span><span class="p">,</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span> 
    <span class="c1"># add other choices</span>
    <span class="c1"># maybe I don&#39;t need a mode</span>
    <span class="c1"># if I supply a -x it will apply transforms</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-a&#39;</span><span class="p">,</span><span class="s1">&#39;--atlas&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the image to be transformed (atlas)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span><span class="s1">&#39;--label&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the label image in atlas space for QC and outputs&#39;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-t&#39;</span><span class="p">,</span><span class="s1">&#39;--target&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the image to be transformed to (target)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-w&#39;</span><span class="p">,</span><span class="s1">&#39;--weights&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the target image weights (defaults to ones)&#39;</span><span class="p">)</span>
    
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span><span class="s1">&#39;--config&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of json config file&#39;</span><span class="p">)</span> <span class="c1"># only required for reg</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-x&#39;</span><span class="p">,</span><span class="s1">&#39;--xform&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify a list of transform files to apply, or a previous output directory&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-d&#39;</span><span class="p">,</span><span class="s1">&#39;--direction&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the direction of transforms to apply, either f for forward or b for backward&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span><span class="s1">&#39;--output&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;A directory for outputs&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--output_image_format&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;File format for outputs (vtk legacy and nibabel supported)&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;.vtk&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--num_threads&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optionally specify number of threads in torch&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--atlas_voxel_scale&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optionally specify a scale factor for atlas voxel size (e.g. 1000 to convert mm to microns)&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--target_voxel_scale&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optionally specify a scale factor for target voxel size (e.g. 1000 to convert mm to microns)&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">num_threads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting numer of torch threads to </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
    

    
    
    <span class="c1"># if mode is register</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;register&#39;</span><span class="p">:</span>   
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting register pipeline&#39;</span><span class="p">)</span>    
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Config file option be set to run registration&#39;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Making output directory </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished making output directory&#39;</span><span class="p">)</span>
    
    
        <span class="c1"># load config</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading config&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">config</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># I&#39;m getting this for initial downsampling for preprocessing</span>
        <span class="n">downJs</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">]</span>
        <span class="n">downIs</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">config</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">config</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished loading config&#39;</span><span class="p">)</span>
        
        <span class="c1"># load atlas</span>
        <span class="c1">#atlas_name = &#39;/home/dtward/data/csh_data/marmoset/Woodward_2018/bma-1-mri-reorient.vtk&#39;</span>
        <span class="c1">#label_name = &#39;/home/dtward/data/csh_data/marmoset/Woodward_2018/bma-1-region_seg-reorient.vtk&#39;</span>
        <span class="c1">#target_name = &#39;/home/dtward/data/csh_data/marmoset/m1229/M1229MRI/MRI/exvivo/HR_T2/HR_T2_CM1229F-reorient.vtk&#39;</span>

        <span class="c1"># TODO check works with nifti</span>
        <span class="n">atlas_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span>
        <span class="k">if</span> <span class="n">atlas_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify an atlas name to run the registration pipeline&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading atlas </span><span class="si">{</span><span class="n">atlas_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>
        <span class="c1">#if parts[-1] != &#39;.vtk&#39;:</span>
        <span class="c1">#    raise Exception(f&#39;Only vtk format atlas supported, but this file is {parts[-1]}&#39;)</span>
        <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas_voxel_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">args</span><span class="o">.</span><span class="n">atlas_voxel_scale</span><span class="p">]</span>
        
        
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># pad the first axis if necessary</span>
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> 
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;3D data required but atlas image has dimension </span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>            
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="s1">&#39;inputs/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
        
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial downsampling so not too much gpu memory&#39;</span><span class="p">)</span>
        <span class="c1"># initial downsampling so there isn&#39;t so much on the gpu</span>
        <span class="n">mindownI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">downIs</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xI</span><span class="p">,</span><span class="n">I</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">mindownI</span><span class="p">)</span>
        <span class="n">downIs</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">/</span><span class="n">mindownI</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downIs</span><span class="p">]</span>
        <span class="n">dI</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">dI</span><span class="p">)</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># update our config variable</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downIs</span>
        
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Atlas image&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="s1">&#39;atlas.png&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished loading atlas&#39;</span><span class="p">)</span>
        
        <span class="c1"># load target and possibly weights</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="n">target_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify a target name to run the registration pipeline&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading target </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading slices from directory&#39;</span><span class="p">)</span>
            <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span> <span class="o">=</span> <span class="n">load_slices</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>            
            
        <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading volume from vtk&#39;</span><span class="p">)</span>
            <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_vtk_data</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span> <span class="c1"># there&#39;s a problem here with marmoset, too many values t ounpack</span>
            <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">J</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">J</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;3D data required but target image has dimension </span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading weights from vtk&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">W0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">target_voxel_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">args</span><span class="o">.</span><span class="n">target_voxel_scale</span><span class="p">]</span>
                
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial downsampling so not too much gpu memory&#39;</span><span class="p">)</span>
        <span class="c1"># initial downsampling so there isn&#39;t so much on the gpu</span>
        <span class="n">mindownJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">downJs</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xJ</span><span class="p">,</span><span class="n">J</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">mindownJ</span><span class="p">)</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">W0</span><span class="p">,</span><span class="n">mindownJ</span><span class="p">)</span>
        <span class="n">downJs</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">/</span><span class="n">mindownJ</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downJs</span><span class="p">]</span>        
        <span class="c1"># update our config variable</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downJs</span>
        
        <span class="c1"># draw it</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Target image&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="s1">&#39;target.png&#39;</span><span class="p">))</span>        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished loading target&#39;</span><span class="p">)</span>
        
        <span class="c1"># get one more qc file applying the initial affine</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># this affine matrix should be 4x4, but it may be 1x4x4</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">XJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xJ</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xs</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Initial transformed atlas&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="s1">&#39;atlas_to_target_initial_affine.png&#39;</span><span class="p">))</span>        

        <span class="c1"># default pipeline</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting registration pipeline&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">emlddmm_multiscale</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I</span><span class="p">)),</span><span class="n">xI</span><span class="o">=</span><span class="p">[</span><span class="n">xI</span><span class="p">],</span><span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)),</span><span class="n">xJ</span><span class="o">=</span><span class="p">[</span><span class="n">xJ</span><span class="p">],</span><span class="n">W0</span><span class="o">=</span><span class="n">W0</span><span class="p">,</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished registration pipeline&#39;</span><span class="p">)</span>
        
        <span class="c1"># write transforms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting to write transforms&#39;</span><span class="p">)</span>
        <span class="n">write_transform_outputs</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished writing transforms&#39;</span><span class="p">)</span>
        
        <span class="c1"># write qc outputs</span>
        <span class="c1"># this requires a segmentation image</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting to read label image for qc&#39;</span><span class="p">)</span>
            <span class="n">xS</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>            
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="c1"># with int32 should be supported by torch</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished reading label image&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting to write qc outputs&#39;</span><span class="p">)</span>
            <span class="n">write_qc_outputs</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">output</span><span class="p">,</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xS</span><span class="o">=</span><span class="n">xI</span><span class="p">,</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished writing qc outputs&#39;</span><span class="p">)</span>
            
            
        <span class="c1"># transform imaging data</span>
        <span class="c1"># transform target back to atlas</span>
        <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]))</span>
        <span class="n">Xout</span> <span class="o">=</span> <span class="n">compose_sequence</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">Xin</span><span class="p">)</span>
        <span class="n">Jt</span> <span class="o">=</span> <span class="n">apply_transform_float</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        
        <span class="c1"># transform atlas to target</span>
        <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]))</span>
        <span class="n">Xout</span> <span class="o">=</span> <span class="n">compose_sequence</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">Xin</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">It</span> <span class="o">=</span> <span class="n">apply_transform_float</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">St</span> <span class="o">=</span> <span class="n">apply_transform_int</span><span class="p">(</span><span class="n">xS</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        <span class="c1"># write</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">output_image_format</span>
        <span class="k">if</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ext</span>
            
        <span class="n">atlas_output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="s1">&#39;to_atlas&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">atlas_output_dir</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">atlas_output_dir</span><span class="p">)</span>
        <span class="n">target_output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="s1">&#39;to_target&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">target_output_dir</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">target_output_dir</span><span class="p">)</span>                
        <span class="c1"># output data in atlas space, use xI for voxel spacing</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">atlas_output_dir</span><span class="p">,</span><span class="s1">&#39;target_to_atlas&#39;</span><span class="o">+</span><span class="n">ext</span><span class="p">),</span><span class="n">xI</span><span class="p">,</span><span class="n">Jt</span><span class="p">,</span><span class="s1">&#39;target_to_atlas&#39;</span><span class="p">)</span>

        <span class="c1"># output data in target space, use xJ for voxel spacing</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_output_dir</span><span class="p">,</span><span class="s1">&#39;atlas_to_target&#39;</span><span class="o">+</span><span class="n">ext</span><span class="p">),</span><span class="n">xJ</span><span class="p">,</span><span class="n">It</span><span class="p">,</span><span class="s1">&#39;atlas_to_target&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_output_dir</span><span class="p">,</span><span class="s1">&#39;atlas_seg_to_target&#39;</span><span class="o">+</span><span class="n">ext</span><span class="p">),</span><span class="n">xJ</span><span class="p">,</span><span class="n">St</span><span class="p">,</span><span class="s1">&#39;atlas_seg_to_target&#39;</span><span class="p">)</span>


        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished registration pipeline&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;transform&#39;</span><span class="p">:</span>
        
        <span class="c1"># now to apply transforms, every one needs a f or a b</span>
        <span class="c1"># some preprocessing</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">)</span>        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;You must input a direction for each transform, but you input </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">)</span><span class="si">}</span><span class="s1"> transforms and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span><span class="si">}</span><span class="s1"> directions&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tform</span><span class="p">,</span><span class="n">direction</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">,</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">direction</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Transform directions must be f or b, but you input </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
            
            
        <span class="c1"># load atlas</span>
        <span class="c1"># load target (to get space info)</span>
        <span class="c1"># compose sequence of transforms</span>
        <span class="c1"># transform the data</span>
        <span class="c1"># write it out</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atlas_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span>
        <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atlas_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify an atlas name or label name to run the transformation pipeline&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading atlas </span><span class="si">{</span><span class="n">atlas_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>        
        <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>        
        
        <span class="c1"># load target and possibly weights</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="n">target_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify a target name to run the transformation pipeline (TODO, support specifying a domain rather than an image)&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading target </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        
        <span class="c1"># to transform an image we start with Xin, and compute Xout</span>
        <span class="c1"># Xin will be the grid of points in target</span>
        <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]))</span>
        <span class="n">Xout</span> <span class="o">=</span> <span class="n">compose_sequence</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">d</span>  <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">,</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="p">],</span> <span class="n">Xin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">It</span> <span class="o">=</span> <span class="n">apply_transform_float</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">It</span> <span class="o">=</span> <span class="n">apply_transform_int</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        
        <span class="c1"># write out the outputs        </span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">output_image_format</span>
        <span class="k">if</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ext</span>                    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="c1"># name should be atlas name to target name, but without the path</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">target_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">name</span><span class="o">+</span><span class="n">ext</span><span class="p">),</span><span class="n">xJ</span><span class="p">,</span><span class="n">It</span><span class="p">,</span><span class="s1">&#39;transformed data&#39;</span><span class="p">)</span>
        <span class="c1"># write a text file that summarizes this</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
         
    
    <span class="c1"># also </span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Daniel Tward, Bryson Gray, Partha Mitra.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>